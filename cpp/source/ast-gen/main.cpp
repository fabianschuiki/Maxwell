/* Copyright © 2013 Fabian Schuiki */

/**
 * @file This tool generates the C++ header and source files for the abstract
 * syntax tree.
 */
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <boost/filesystem.hpp>

using std::cout;
using std::endl;
using std::string;
using std::map;
using std::set;
using std::ofstream;
using std::vector;

class Node
{
public:
	string name;
	string parent;

	struct Field {
		string name;
		string type;
		string cpp_type;
		bool isString;
		bool isArray;
		bool isNode;
		vector<string> allowedNodes;
		vector<string> allowedInterfaces;
	};
	typedef vector<Field> Fields;
	Fields children, attributes;

	Node& child(string name, string type) { children.push_back(makeField(name, type)); return *this; }
	Node& attr(string name, string type) { attributes.push_back(makeField(name, type)); return *this; }

private:
	Field makeField(string name, string type)
	{
		Field f;
		f.name = name;
		f.type = type;
		f.isString = false;
		f.isArray = false;
		f.isNode = false;
		if (type == "string") {
			f.isString = true;
			f.cpp_type = "string";
		} else if (type.size() > 2 && type[0] == '[') {
			f.isArray = true;
			f.cpp_type = "vector<shared_ptr<Node> >";
		} else {
			f.isNode = true;
			f.cpp_type = "shared_ptr<Node>";
			f.allowedNodes.push_back(type);
		}
		return f;
	}
};

class Builder
{
public:
	Node& operator() (const string& nodeName, const string& parentName = "Node")
	{
		Node &n = nodes[nodeName];
		n.name = nodeName;
		n.parent = parentName;
		return n;
	}
	typedef map<string, Node> Nodes;
	Nodes nodes;
};

typedef vector<string> Headers;

/**
 * This function generates all AST nodes. It is called by the main function
 * to build the AST before the nodes are generated.
 */
void buildAST(Builder &node)
{
	node("FunctionDefinition")
		.attr("name", "string")
		.attr("in", "FuncArgTuple")
		.attr("out", "FuncArgTuple")
		.attr("body", "FuncBody");

	node("FuncArgTuple")
		.attr("args", "[FuncArg]");
	node("FuncArg")
		.attr("name", "string")
		.attr("type", "string");

	node("FuncBody")
		.attr("stmts", "[Stmt]");
}

void makeTypesHeader(const boost::filesystem::path& output, const Builder& builder)
{
	boost::filesystem::path path = output;
	path /= "types.hpp";
	ofstream h(path.c_str());
	h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	h << "#pragma once\n\n";
	h << "namespace ast {\n\n";
	h << "/// Node kinds that may be used to test whether a Node is of a given subclass.\n";
	h << "typedef enum {";
	bool first = true;
	for (Builder::Nodes::const_iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		h << (first ? "\n" : ",\n");
		h << "\tk" << it->first;
		first = false;
	}
	h << "\n} Kind;\n";
	h << "\n} // namespace ast\n\n";
}

typedef set<string> NodeNames;
void generateFactoryBody(std::ostream& out, NodeNames names, int indent, string basePrefix = "")
{
	string pad(indent, '\t');

	// Extract the prefixes.
	string prefix;
	string commonPrefix = basePrefix;
	bool common = true;
	int guard = 0;
	do {
		if (guard++ > 15) break;
		NodeNames newNames;
		NodeNames::iterator nambeg = names.begin();
		bool singleMatch = false;
		if ((*nambeg).size() == commonPrefix.size()) {
			newNames.insert(*nambeg);
			names.erase(nambeg);
			//cout << "one name equals common prefix " << commonPrefix << "\n";
			prefix = commonPrefix;
			singleMatch = true;
		} else {
			prefix = commonPrefix + (*nambeg)[commonPrefix.size()];
			//cout << "prefix " << prefix << "\n";
			for (NodeNames::iterator it = names.begin(); it != names.end();) {
				string name = *it;
				NodeNames::iterator tmpit = it;
				it++;
				if (name.size() < prefix.size() || name.substr(0, prefix.size()) != prefix)
					break;
				newNames.insert(name);
				names.erase(tmpit);
				//cout << "- adding " << name << "\n";
			}
		}
		if (names.empty() && common && !singleMatch) {
			commonPrefix = prefix;
			names = newNames;
			//cout << "all names consumed\n";
		} else {
			if (common) {
				common = false;
				out << pad << "// " << commonPrefix << ".*\n";
				out << pad << "if (size >= " << commonPrefix.size();
				for (int i = basePrefix.size(); i < commonPrefix.size(); i++) {
					out << " && name[" << i <<"] == '" << commonPrefix[i] << "'";
				}
				out << ") {\n";
			}
			//cout << "-> generating subbranch for " << commonPrefix << " with " << newNames.size() << " names, with " << names.size() << " names remaining\n";
			if (newNames.size() > 1 || (newNames.size() == 1 && !singleMatch)) {
				generateFactoryBody(out, newNames, indent + 1, commonPrefix);
			} else {
				string name = *newNames.begin();
				out << pad << "\t// " << name << "\n";
				out << pad << "\tif (size == " << name.size() << ") ";
				out << "return shared_ptr<Node>(new " << name << ");\n";
			}
		}
	} while (!names.empty());
	if (!common) {
		out << pad << "}\n";
	}
	//cout << "common prefix = " << commonPrefix << "\n";
}

void makeNodesHeader(const boost::filesystem::path& output, const Builder& builder, const Headers& headerFileNames)
{
	boost::filesystem::path path = output;
	path /= "nodes.hpp";
	ofstream h(path.c_str());
	h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	h << "#pragma once\n#include <string>\n\n";
	for (Headers::const_iterator it = headerFileNames.begin(); it != headerFileNames.end(); it++) {
		h << "#include \"" << *it << "\"\n";
	}

	// Generate the node factory class.
	h << "\nnamespace ast {\n\n";
	h << "using std::string;\n\n";
	h << "/// Node factory.\n";
	h << "class NodeFactory\n{\npublic:\n";
	h << "\tshared_ptr<Node> make(const string& name)\n\t{\n";
	h << "\t\tsize_t size = name.size();\n";
	NodeNames names;
	for (Builder::Nodes::const_iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		names.insert(it->first);
	}
	generateFactoryBody(h, names, 2);
	h << "\t\treturn shared_ptr<Node>();\n";
	h << "\t}\n";
	h << "};\n";
	h << "\n} // namespace ast\n\n";
}

int main(int argc, char *argv[])
{
	// Parse command line arguments.
	boost::filesystem::path output(".");
	if (argc >= 2) output = argv[1];

	// Create the output directory if required.
	if (!boost::filesystem::exists(output)) {
		cout << "Creating output directory " << output << endl;
		boost::filesystem::create_directory(output);
	}

	// Build the AST.
	Builder builder;
	buildAST(builder);

	// Generate the code for the nodes.
	Headers headerFileNames;
	for (Builder::Nodes::iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		const string &name = it->first;
		Node &node = it->second;
		cout << "- Generating \033[36;1m" << name << "\033[0m" << endl;
		string headerName = name + ".hpp";

		// Generate the header file.
		boost::filesystem::path hpath = output;
		hpath /= headerName;
		ofstream h(hpath.c_str());
		h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
		h << "#pragma once\n";
		h << "#include \"../Node.hpp\"\n";
		h << "#include <vector>\n#include <string>\n#include <sstream>\n#include <boost/smart_ptr.hpp>\n#include <stdexcept>\n\n";
		h << "namespace ast {\n\n";
		h << "using std::vector;\nusing std::string;\nusing std::stringstream;\nusing std::endl;\nusing boost::shared_ptr;\nusing std::runtime_error;\n\n";
		h << "class " << name << " : public Node\n{\n";

		h << "public:\n";
		h << "\t" << name << "() : Node() {}\n\n";
		h << "\tvirtual bool isKindOf(Kind k)\n\t{\n";
		h << "\t\tif (" << node.parent << "::isKindOf(k)) return true;\n";
		h << "\t\treturn k == k" << node.name << ";\n";
		h << "\t}\n\n";
		h << "\tvirtual string getClassName() const { return \"" << node.name << "\"; }\n\n";

		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			string ref = "const " + f.cpp_type + "&";
			string upper = f.name;
			if (!upper.empty()) upper[0] = toupper(upper[0]);
			h << "\tvoid set" << upper << "(" << ref << " v)\n\t{\n";

			vector<string> ifcomponents;
			string allowedNodes;
			string allowedInterfaces;
			for (int i = 0; i < f.allowedNodes.size(); i++) {
				ifcomponents.push_back("!v->isKindOf(k" + f.allowedNodes[i] + ")");
				if (!allowedNodes.empty()) allowedNodes += ", ";
				allowedNodes += f.allowedNodes[i];
			}
			if (!ifcomponents.empty()) {
				h << "\t\tif (v";
				for (int i = 0; i < ifcomponents.size(); i++) {
					h << " && " << ifcomponents[i];
				}
				h << ") {\n";
				h << "\t\t\tthrow runtime_error(\"'" << f.name << "' needs to be of kind {" << allowedNodes << "} or implement interface {" << allowedInterfaces << "}.\");\n";
				h << "\t\t}\n";
			}

			h << "\t\tif (v != " << f.name << ") {\n";
			h << "\t\t\tmodify();\n";
			h << "\t\t\t" << f.name << " = v;\n";
			h << "\t\t}\n";
			h << "\t}\n";

			h << "\t" << ref << " get" << upper << "()\n\t{\n";
			h << "\t\treturn " << f.name << ";\n\t}\n\n";
		}

		// Generate the describe() function.
		h << "\tvirtual string describe(int depth = -1)\n\t{\n";
		h << "\t\tif (depth == 0) return \"" << name << "{…}\";\n";
		h << "\t\tstringstream str, b;\n";
		h << "\t\tstr << \"" << name << "{\";\n";
		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			if (f.isString) {
				h << "\t\tif (!this->"<<f.name<<".empty()) b << endl << \"  \\033[1m"<<f.name<<"\\033[0m = '\\033[33m\" << this->"<<f.name<<" << \"\\033[0m'\";\n";
			} else if (f.isNode) {
				h << "\t\tif (this->"<<f.name<<") b << endl << \"  \\033[1m"<<f.name<<"\\033[0m = \" << indent(this->"<<f.name<<"->describe(depth-1));\n";
			} else if (f.isArray) {
				h << "\t\tif (!this->"<<f.name<<".empty()) b << endl << \"  \\033[1m"<<f.name<<"\\033[0m = [\" << this->"<<f.name<<".size() << \" nodes]\";\n";
			}
		}
		h << "\t\tstring bs = b.str();\n";
		h << "\t\tif (!bs.empty()) str << bs << endl;\n";
		h << "\t\tstr << \"}\";\n";
		h << "\t\treturn str.str();\n";
		h << "\t}\n";

		h << "protected:\n";
		for (Node::Fields::iterator f = node.attributes.begin(); f != node.attributes.end(); f++) {
			h << "\t" << (*f).cpp_type << " " << (*f).name << ";\n";
		}

		h << "};\n\n";
		h << "} // namespace ast";
		headerFileNames.push_back(headerName);
	}

	// Generate the header file containing general typedefs.
	makeTypesHeader(output, builder);
	makeNodesHeader(output, builder, headerFileNames);

	// Generate the header file aggregating all AST things.
	boost::filesystem::path ahpath = output;
	ahpath /= "ast.hpp";
	ofstream ah(ahpath.c_str());
	ah << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	ah << "#pragma once\n\n";
	ah << "#include \"types.hpp\"\n";
	ah << "#include \"nodes.hpp\"\n";

	return 0;
}
/* Copyright Â© 2013 Fabian Schuiki */

/**
 * @file This tool generates the C++ header and source files for the abstract
 * syntax tree.
 */
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <boost/filesystem.hpp>

using std::cout;
using std::endl;
using std::string;
using std::map;
using std::ofstream;

class Node
{
public:
	string name;
};

class Builder
{
public:
	Node& operator() (const string& nodeName) { Node &n = nodes[nodeName]; n.name = nodeName; return n; }
	typedef map<string, Node> Nodes;
	Nodes nodes;
};

/**
 * This function generates all AST nodes. It is called by the main function
 * to build the AST before the nodes are generated.
 */
void buildAST(Builder &node)
{
	node("FunctionDefinition");
}

int main(int argc, char *argv[])
{
	// Parse command line arguments.
	boost::filesystem::path output(".");
	if (argc >= 2) output = argv[1];

	// Create the output directory if required.
	if (!boost::filesystem::exists(output)) {
		cout << "Creating output directory " << output << endl;
		boost::filesystem::create_directory(output);
	}

	// Build the AST.
	Builder builder;
	buildAST(builder);

	// Generate the code for the nodes.
	for (Builder::Nodes::iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		const string &name = it->first;
		Node &node = it->second;
		cout << "- Generating \033[36;1m" << name << "\033[0m" << endl;

		// Generate the header file.
		boost::filesystem::path hpath = output;
		hpath /= name + ".hpp";
		ofstream h(hpath.c_str());
		h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
		h << "#pragma once\n";
		h << "#include \"ast.hpp\"\n\n";
		h << "namespace ast {\n\n";
		h << "class " << name << " : public Node\n{\n";
		h << "};\n\n";
		h << "} // namespace ast";


	}

	return 0;
}
/* Copyright (c) 2014 Fabian Schuiki */
#include "maxwell/backend/c/Packager.hpp"
#include "maxwell/backend/c/Packager-detail.hpp"
#include <iostream>
using namespace backendc;


static bool isHeader(const std::string& name)
{
	return name.substr(name.length()-2) == ".h";
}

static void compileGroup(Group* grp, std::string& output)
{
	output += "/* This file was automatically generated by the Maxwell C backend. */\n";
	if (isHeader(grp->name))
		output += "#pragma once\n";

	// Include the groups this group depends on. Make sure that only header
	// files are included.
	for (std::vector<Group*>::iterator k = grp->deps.begin(); k != grp->deps.end(); k++) {
		if (!isHeader((*k)->name))
			throw std::runtime_error("Group '" + grp->name + "' depends on other group '" + (*k)->name + "' which is not a header file");
		output += "#include \"" + (*k)->name + "\"\n";
	}

	// Insert the fragments.
	bool wasOneline = false;
	for (std::vector<Fragment*>::iterator k = grp->frags.begin(); k != grp->frags.end(); k++) {
		bool oneline = (*k)->code.find_first_of('\n') == std::string::npos;
		if (!oneline || !wasOneline)
			output += "\n";
		output += (*k)->code + "\n";
		wasOneline = oneline;
	}
}

void Packager::compile()
{
	for (std::map<std::string,Group*>::iterator i = groups.begin(); i != groups.end(); i++) {
		std::string& output = files[i->first];
		output.clear();
		compileGroup(i->second, output);
	}
}

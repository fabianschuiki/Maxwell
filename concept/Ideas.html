<!DOCTYPE html>
<html>
<head>
	<title>Maxwell – Ideas</title>
	<meta charset="utf-8"/>
	<script src="http://code.jquery.com/jquery-1.6.2.min.js" type="text/javascript"></script>
	<script src="include/include.js" type="text/javascript"></script>
	<link rel="stylesheet" href="include/include.css" type="text/css" />
</head>
<body>

<h1>If Expression</h1>
<p>It should be possible to have complex if statements as expressions, similar to how cases are notated in mathematics.</p>
<code>a.doSomethingWith({0 if x == "null", 1 otherwise});</code>
<p>Or, in a more elaborate case:</p>
<code>var int x = getUserInput();
var String b = {
	"0" if x == 0,
	"1" if x == 1,
	">1" otherwise };</code>


<h1>"incase" Statement/Expression</h1>
<p>The <em>incase</em> keyword should introduce a construct that implements and extends the well-known <em>switch and case</em> statement. The keyword may be used as a statement, taking statements or blocks as case arguments; or as an expression, taking any expressions as case arguments. The construct allows a sequence of binary operator expressions with the same left hand side operand and optionally the same operator to be written in a compact manner.</p>
<code>var int x = getUserInput();
if (x == 0)
	doA();
if (x == 1)
	doB();
if (x == 2)
	doC();
</code>
<p>In the preceding code, all <em>if</em> statements share the same LHS operand and operator, namely <code>x ==</code>. Using the <code>incase</code> keword, these statements may be simplified to:</p>
<code>incase x == 0: doA(), 1: doB(), 2: doC();

// or easier to read on multiple lines
incase x ==
	0: doA(),
	1: doB(),
	2: doC();</code>

<p>In case the LHS is the same but the operator changes:</p>
<code>incase x == 0: doA(), &lt;= -1: doB(), &gt;= 1: doC();

// or easier to read on multiple lines
incase x
	== 0: doA(),
	&lt;= 1: doB(),
	&gt;= 1: doC();</code>

<p>To make it possible to contract <em>if/else if/else</em> constructs, the <code>otherwise</code> keyword allows for the <em>else</em> part:</p>
<code>incase x == 0: doA(), 1: doB(), otherwise: doC();</code>


<h1>Option Types</h1>
<p>The planned type inferrence strongly suggests the support of option types, i.e. a special type that is a set of actual types. This allows a variable to be expressed as being either of type "A or B".</p>
<code>var String|Error r = getUserInput();</code>

<h2>Implications</h2>
<p>One implication of option types is that it allows for very rigorous type checking. If <em>String</em> has a function <code>getLength()</code> and <em>Error</em> a function <code>getMessage()</code>, the statement…</p>
<code>r.getLength();
r.getMessage();</code>
<p>…will throw an error, since neither of the two functions is supported by both types. In case there is some powerful assumption logic in place, the following would work:</p>
<code>if (r isa String) {
	//In this scope, r is of type String.
	r.getLength();
}
if (r isa Error) {
	//In this scope, r is of type Error.
	r.getMessage();
}</code>



<h1>String Formatting</h1>
<p>In general, there should be a function that allows a string to be formatted by replacing special template characters (e.g. <em>%s</em>) with appropriate values from a value map or array. Syntactic sugar should be available to make this process as easy as possible:</p>
<code>var int x = 1;
var float y = 1.2345;
var String text = "We have an int %{x}, some float %{y} and a float as int %i{x}.";
</code>
<p>The last line of the snippet should automatically be converted to:</p>
<code>var String text = "We have an int %i, some float %f and a float as int %i.".format([x, y, x]);</code>



<h1>Nullable Types</h1>
<p>Variables with an object type should not automatically accept <code>null</code> or <code>nil</code> as a value, even if the C backend has nullable pointers for free. This enables the programmer to clearly distinguish functions that always return a value and those that may return null.</p>
<code>func loadWebsite -> (<span class="type">String|null</span>) { ... } //This function returns the contents of the website on success, or null if an error occurred.

var String google = loadWebsite(); //Fails to compile, since the variable mustn't be null.
var String|null google = loadWebsite(); //Works.</code>

<h2>Implications</h2>
<p>Combined with type inferrence and some powerful assumption logic, this allows for some nice error checking that may catch a lot of the classic <em>null-pointer dereferencing</em> issues at compile time:</p>
<code>//loadWebsite() as above
var any google = loadWebsite(); //Type detected to be String|null.

//The following will fail and prevent a null-dereferencing segfault…
var int length = google.length(); //…since no functions can be called on null.

//The following will work…
if (google == null)
	return;
var int length = google.length(); //…since the compiler assumes the variable to be of type String after the if-statement.</code>

</body>
</html>
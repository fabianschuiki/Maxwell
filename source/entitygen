#!/usr/bin/php
<?php
/* Copyright © 2013 Fabian Schuiki
 * Generates entities according to the Entities.json file.*/

// Read the definitions.
$defs_file = __DIR__."/Entities.json";
if (!file_exists($defs_file)) {
	echo "definitions file $defs_file does not exist\n";
	exit(1);
}
$defs = json_decode(file_get_contents($defs_file));
if (!$defs) {
	echo "unable to read definitions, JSON error ".json_last_error()."\n";
	exit(1);
}

// Create the output directory if required.
$dir = __DIR__."/Objects";
if (!file_exists($dir)) {
	if (!mkdir($dir)) {
		echo "unable to make output directory $dir\n";
		exit(1);
	}
}

// General purpose functions.
function makeInterfaceName($n)
{
	return str_replace(" ", "", ucwords(str_replace("_", " ", $n)))."Interface";
}

function processType($t)
{
	return str_replace(
		array(".", "array", "ref"),
		array("\\", "\\RepositoryObjectArray", "\\RepositoryObjectReference"),
		$t);
}

// Types considered scalar.
$scalarTypes = array("string", "bool", "numeric");

// Create an interface file for each interface.
$interface_defs = $defs->interfaces;
foreach ($interface_defs as $name => $def)
{
	$interfaceName = makeInterfaceName($name);

	// Analyse types.
	$canonicalProperties = array();
	foreach ($def as $i => $property) {
		if (!preg_match('/(([^\s]+)\s+)?(\w+)/', $property, $m)) {
			echo "invalid property \"$property\"\n";
			exit(1);
		}
		$p = new stdClass;
		$p->name = $m[3];
		$p->type = processType($m[2]);
		$canonicalProperties[$i] = $p;
	}

	// Create the accessors for each property.
	$body = "";
	foreach ($canonicalProperties as $property) {
		$lcname = $property->name;
		$ucname = ucfirst($lcname);
		$scalarType = in_array($property->type, $scalarTypes);
		$refable = !$scalarType;

		// SETTER
		$body .= "public function set{$ucname}(\$$lcname, \$notify = true);\n";
		if ($refable) {
			$body .= "public function set{$ucname}Ref(\$$lcname, \\Repository \$repository, \$notify = true);\n";
		}

		// GETTER
		$body .= "public function get{$ucname}(\$enforce = true";
		if ($refable) $body .= ", \$unref = true";
		$body .= ");\n\n";
	}

	// Generate the class creation code.
	$output = "<?php\n/* Copyright © 2013 Fabian Schuiki.\n * Automatically generated interface. */\n";
	$output .= "namespace Objects;\n\n";
	$output .= "interface $interfaceName\n{\n\t";
	$output .= str_replace("\n", "\n\t", trim($body));
	$output .= "\n}";

	// Store the code to disk.
	$file = $dir."/$interfaceName.php";
	file_put_contents($file, $output);
}

// Create an entity for each entity.
$entity_defs = $defs->entities;
foreach ($entity_defs as $name => $def)
{
	// Strip out the magic properties.
	$implements = (isset($def->implements) ? $def->implements : array());
	unset($def->implements);
	if (is_array($implements))
		$interfaces = $implements;
	else
		$interfaces = array($implements);
	$superclass = (isset($def->root) && $def->root === true ? "\\RepositoryRootObject" : "\\RepositoryNodeObject");
	if (isset($def->extends))
		$superclass = $def->extends;
	unset($def->extends);
	unset($def->root);

	// Generate the fragments.
	$afragments = array();
	$afragments[] = 
		"protected \$parent = null;\n".
		"protected \$parent_key = null;\n".
		"protected \$parent_fragment = null;";
	$bfragments = array();
	$propertiesByFragment = array();
	foreach ($def as $fragmentName => $properties) {
		$prop_dirty  = "{$fragmentName}_dirty";
		$prop_loaded = "{$fragmentName}_loaded";

		$afragment  = "// $fragmentName fragment\n";
		$afragment .= "public \$$prop_dirty  = false;\n";
		$afragment .= "public \$$prop_loaded = true;";

		// Resolve interfaces.
		$canonicalProperties = array();
		if (!is_array($properties)) {
			echo "Invalid list of properties in {$name}.{$fragmentName}\n";
			exit(1);
		}
		foreach ($properties as $property) {
			if ($property[0] === "@") {
				$interfaceName = substr($property, 1);
				if (!isset($interface_defs->$interfaceName)) {
					echo "unknown interface \"$interfaceName\" in fragment \"$fragmentName\" of $name\n";
					exit(1);
				}
				foreach ($interface_defs->$interfaceName as $p)
					$canonicalProperties[] = $p;
				$interfaces[] = makeInterfaceName($interfaceName);
			} else {
				$canonicalProperties[] = $property;
			}
		}

		// Analyse types.
		foreach ($canonicalProperties as $i => $property) {
			if (!preg_match('/(([^\s]+)\s+)?(\w+)/', $property, $m)) {
				echo "invalid property \"$property\"\n";
				exit(1);
			}
			$p = new stdClass;
			$p->name = $m[3];
			$p->type = processType($m[2]);
			$canonicalProperties[$i] = $p;
		}
		$propertiesByFragment[$fragmentName] = $canonicalProperties;

		// Create a property statement for each property.
		foreach ($canonicalProperties as $property) {
			$afragment .= "\nprotected \${$property->name};";
		}

		// Create the accessors for each property.
		$bfragment = "";
		foreach ($canonicalProperties as $property) {
			$lcname = $property->name;
			$ucname = ucfirst($lcname);
			$scalarType = in_array($property->type, $scalarTypes);
			$refable = !$scalarType;

			// SETTER
			$bfragment .= "public function set{$ucname}(\$$lcname, \$notify = true)\n{\n";
			
			// Perform a data type check.
			if ($property->type == "string") {
				$bfragment .= 
					"\tif (!is_string(\$$lcname)) {\n".
					"\t\tthrow new \\InvalidArgumentException(\"$lcname needs to be a string\");\n".
					"\t}\n";
			}
			if ($property->type == "bool") {
				$bfragment .=
					"\tif (!is_bool(\$$lcname)) {\n".
					"\t\tthrow new \\InvalidArgumentException(\"$lcname needs to be a boolean\");\n".
					"\t}\n";
			}
			if ($property->type == "numeric") {
				$bfragment .=
					"\tif (!is_numeric(\$$lcname)) {\n".
					"\t\tthrow new \\InvalidArgumentException(\"$lcname needs to be a number\");\n".
					"\t}\n";
			}
			$types = array_filter(preg_split('/\s*\|\s*/', $property->type));
			$typecheck = "";
			if ($types && !$scalarType) {
				$checktypes = $types;
				$objrefclass = "\\RepositoryObjectReference";
				if (!in_array($objrefclass, $checktypes)) {
					$checktypes[] = $objrefclass;
				}
				$iof = array_map(function($t) use ($lcname) {
					return "!\$$lcname instanceof $t";
					}, $checktypes);
				$typecheck =
					"\tif (".implode(" && ", $iof).") {\n".
					"\t\tthrow new \\InvalidArgumentException('Object '.\$this->getId().' needs $lcname to be an instance of ".implode(" or ", $checktypes)."');\n".
					"\t}\n";
			}
			$bfragment .= $typecheck;

			// Check whether the property has changed or needs to be loaded.
			if ($scalarType) {
				$changeCheck = "\$this->$lcname !== \$$lcname";
			} else {
				$changeCheck = "\$this->hasPropertyChanged(\$this->$lcname, \$$lcname)";
			}
			$bfragment .=
				"\tif ($changeCheck) {\n".
				"\t\tif (!\$this->$prop_loaded) {\n".
				"\t\t\t\$this->loadFragment(\"$fragmentName\");\n".
				"\t\t}\n";

			// Maintain the object hierarchy.
			if (!$scalarType) {
				$bfragment .=
					"\t\tif (\$this->$lcname instanceof \\RepositoryObjectParentInterface) {\n".
					"\t\t\t\$this->{$lcname}->setParent(null);\n".
					"\t\t}\n".
					"\t\tif (\$$lcname instanceof \\RepositoryObjectParentInterface) {\n".
					"\t\t\t\${$lcname}->setParent(\$this, \"$lcname\", \"$fragmentName\");\n".
					"\t\t}\n";
			}

			// Store the new value and notify the object hierarchy about the change.
			$bfragment .= "\t\t\$this->$lcname = \$$lcname;\n";
			$bfragment .=
				"\t\tif (\$notify) {\n".
				"\t\t\t\$this->notifyObjectDirty(\"$lcname\");\n".
				"\t\t\t\$this->notifyFragmentDirty(\"$fragmentName\");\n".
				"\t\t}\n".
				"\t}\n".
				"}\n";

			// REFERENCING SETTER
			if ($refable) {
				$bfragment .= "public function set{$ucname}Ref(\$$lcname, \\Repository \$repository, \$notify = true)\n{\n";
				$bfragment .= $typecheck;
				$bfragment .=
					"\t\$v = new \\RepositoryObjectReference(\$repository);\n".
					"\tif (\$$lcname instanceof \\RepositoryObjectReference) {\n".
					"\t\t\$v->set(\${$lcname}->getRefId());\n".
					"\t} else {\n".
					"\t\t\$v->set(\$$lcname);\n".
					"\t}\n".
					"\t\$this->set{$ucname}(\$v, \$notify);\n";
				$bfragment .= "}\n";
			}


			// GETTER
			$bfragment .= "public function get{$ucname}(\$enforce = true";
			if ($refable) {
				$bfragment .= ", \$unref = true";
			}
			$bfragment .= ")\n{\n";
			$bfragment .= 
				"\tif (!\$this->$prop_loaded) {\n".
				"\t\t\$this->loadFragment('$fragmentName');\n".
				"\t}\n".
				"\tif (\$enforce && \$this->$lcname === null) {\n".
				"\t\tthrow new \\RuntimeException(\"Object {\$this->getId()} expected to have non-null $lcname.\");\n".
				"\t}\n";

			// Unreference if required.
			if ($refable) {
				$bfragment .=
					"\tif (\$unref && \$this->$lcname instanceof \\RepositoryObjectReference) {\n".
					"\t\t\$v = \$this->{$lcname}->get(!\$enforce);\n".
					"\t} else {\n".
					"\t\t\$v = \$this->{$lcname};\n".
					"\t}\n".
					"\treturn \$v;\n";
			} else {
				$bfragment .=
					"\treturn \$this->$lcname;\n";
			}

			// Return the value.
			$bfragment .= "}\n\n";
		}

		// Store the generated fragment.
		$afragments[] = $afragment;
		$bfragments[] = trim($bfragment);
	}

	// Assemble the general interface.
	$general = array();
	$general[] = "public function setParent(\\IdedObject \$parent = null, \$key = null, \$fragment = null)\n".
		"{\n".
		"\tif (\$this->parent !== null && \$parent !== null) {\n".
		"\t\tthrow new \\RuntimeException(\"Setting parent to {\$parent->getId()} when object already has parent {\$this->parent->getId()}.\");\n".
		"\t}\n".
		"\t\$this->parent = \$parent;\n".
		"\t\$this->parent_key = \$key;\n".
		"\t\$this->parent_fragment = \$fragment;\n".
		"}";
	$general[] = "public function __clone()\n".
		"{\n".
		"\t\$this->parent = null;\n".
		"\t\$this->parent_key = null;\n".
		"\t\$this->parent_fragment = null;\n".
		"}";
	$fragNames = array_map(function($n){ return "\"$n\""; }, array_keys(get_object_vars($def)));
	$general[] = "public function getFragmentNames()\n{\n\treturn array(".implode(",", $fragNames).");\n}";
	$gf = "public function getFragment(\$name)\n{\n\tswitch (\$name) {";
	foreach (array_keys(get_object_vars($def)) as $fragmentName) {
		$ps = array();
		foreach ($propertiesByFragment[$fragmentName] as $p) {
			$ps[] = "\n\t\t\tarray(\"name\" => \"{$p->name}\", \"type\" => \"{$p->type}\")";
		}
		$gf .= "\n\t\tcase \"$fragmentName\": return array(".implode(", ", $ps).");";
	}
	$gf .= "\n\t}\n\tthrow new \\RuntimeException(\"Fragment \$name does not exist.\");\n}";
	$general[] = $gf;
	$general[] = "public function getClass()\n{\n\treturn \"$name\";\n}";

	// Assemble the class body.
	$body  = "/* PROPERTIES */\n".implode("\n\n", $afragments)."\n\n\n";
	$body .= "/* GENERAL */\n".implode("\n\n", $general)."\n\n\n";
	$body .= "/* ACCESSORS */\n".implode("\n\n", $bfragments);

	// Generate the class creation code.
	$output = "<?php\n/* Copyright © 2013 Fabian Schuiki.\n * Automatically generated entity. */\n";
	$output .= "namespace Objects;\n\n";
	$output .= "class $name extends $superclass";
	if (count($interfaces))
		$output .= " implements ".implode(", ", $interfaces);
	$output .= "\n{\n\t";
	$output .= str_replace("\n", "\n\t", trim($body));
	$output .= "\n}";

	// Store the code to disk.
	$file = $dir."/$name.php";
	file_put_contents($file, $output);
}
/**
 * MAXWELL TYPE INFERENCE
 *
 * Show-off of the type inference system of the Maxwell programming language. Read the comments in
 * 'main' to understand what's going on.
 *
 * (Known to work with commit 8f833dc)
 */

//Square roots.
func sqrt (int a) -> (int r) {}
func sqrt (float a) -> (float r) {}

//A mathematical vector.
type Vector
{
	var x;
	var y;
	
	func (*) (Vector other) -> (result) { result = this.x*other.x + this.y*other.y; }
	func (+) (Vector other) -> (Vector result) { result.x = this.x + other.x; result.y = this.y + other.y; }
	func (-) (Vector other) -> (Vector result) { result.x = this.x - other.x; result.y = this.y - other.y; }
	func (=) (Vector other) { this.x = other.x; this.y = other.y; }
}

//A mathematical norm.
func norm (a) -> (v) { v = sqrt(a*a); }

//A straight line between two points.
type Line
{
	var Vector s;
	var Vector e;
	
	func direction () -> (d) { d = this.e - this.s; }
	func length () -> (l) { l = norm(direction(this)); }
}

//Main function.
func main
{
	/**
	 * GENERIC FUNCTIONS
	 * -----------------
	 * Note that the 'norm' function is generic as it does not specify its input nor its output type.
	 * All 'norm' requires is that whatever you pass to it as 'a' has to have a multiplication with
	 * itself defined, for whose result type a function sqrt exists. Two functions sqrt whose input and
	 * output types are the same.
	 *
	 * - The first call norm(f) will cause the compiler to create a version of 'norm' that is
	 *   specialized for inputs of type float. The output type will also be float, since float * float
	 *   yields another float, and sqrt(float) returns a float as well.
	 * - The second call norm(v) will create a specialization for inputs of type Vector with float
	 *   components. The multiplication of two float vectors returns a float scalar (see func (*) ...),
	 *   which sqrt leaves as float again.
	 *
	 * Both calls to 'norm' return a float. Thanks to generic programming, describing the overall
	 * concept of a norm (square root of a value's dot product) suffices. The compiler generates the
	 * appropriate specialized versions for you.
	 *
	 * NOTE: Due to a compiler bug, the calls to 'norm' have to be commented out if you want to test
	 * the generic types.
	 */
	
	//Declare a float and a vector of floats. The weird notation is required to fix the vector's
	//component type to float.
	var float f;
	var Vector v;
	v.x = f;
	v.y = f;
	
	//norm(f);
	//norm(v);
	
	
	/**
	 * GENERIC TYPES
	 * -------------
	 * Note that the Line type is generic, since it contains two members of generic type Vector.
	 * Vector is generic since it contains the fields x,y whose type is not further specified.
	 * 
	 * Compiling with only the variable defined will cause the compiler to complain that Line l is of
	 * generic type.
	 */
	 
	//Declare a new Line object.
	var Line l;
	
	
	/**
	 * Now uncomment the first call. Compilation will fail since l is generic, which will
	 * cause the result of length(l) to be generic as well.
	 *
	 * Now uncomment the second call (and recomment the first). Compilation will actually succeed.
	 * Why is that?
	 * - Assigning the result of length(l) to a variable of type int will force the result of length(l)
	 *   to be an int as well. This will cause the compiler to specialize 'length' for the return
	 *   type int.
	 * - The specialization will cause the result of norm(...) called inside 'length' to be forced to
	 *   int as well. Since 'norm' is a generic function, the compiler will specialize it for the
	 *   return type int.
	 * - A return type of int will cause 'norm' to use the 'sqrt' function that maps an integer to its
	 *   integer square root. This implies that the result of 'a*a' is an integer. 'a' in this case is
	 *   the result of 'direction(this)', as passed in from the call to 'length'.
	 * - The compiler knows the result of 'direction(this)' is some 'Vector', since the only sub-
	 *   traction of two Vectors is defined to return a 'Vector' again (see function inside 'Vector').
	 * - With a being some 'Vector' the compiler uses the only multiplication (*) for two 'Vectors'
	 *   available, whose result is forced to be of the same type as the individual 'Vector'
	 *   components. With the result of 'a*a' forced to int, the 'Vector' components x,y are forced to
	 *   int as well.
	 * - This forces direction(this) to return a Vector with int as component type, which in turn
	 *   forces the line's 'e' and 's' Vectors to be of that type too.
	 * - This ultimately causes the compiler to specialize the 'l' variable's type to a Line with two
	 *   integer vectors. This Line is not generic anymore, which allows it to be compiled.
	 */  
	
	//1: Will fail to compile.
	//var x = length(l);
	
	//2: Will succeed to compile.
	var int x = length(l);
}

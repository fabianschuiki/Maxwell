/* This snippet of source code is supposed to help point out to what extent we try to push the
 * «Don't Repeat Yourself» paradigm in Maxwell. */


class Item
{
	//Location of the item inside the tower.
	//One type and initial value, multiple variables.
	int (floor, location) = 0;
	
	
	//Make the general properties of the item accessible to the outside world.
	property floor;
	property location;
	
	//Properties with the same mutability may be written together.
	// readwrite is the default, allowing properties to be changed from outside the class
	// readonly  allows properties to only be changed from inside the class or one of its subclasses
	// const     disallows any outside changes to the property. The only way such a property can
	//             modify its value is through a lazy expression that is reevaluated.
	property (
		readwrite (
			floor,
			location,
			rating
		),
		readonly (
			price,
			population
		),
		const (
			position
		)
	);
	
	//Declarations do not have to be in order. The position property was defined without the pos-
	//sition variable declared.
	//Note that the position is assigned an expression rather than a value. This is a technique
	//found in functional programming where you describe the relationships of values rather than
	//the step-by-step procedure to find the final result. Whenever floor or location changes the
	//expression is re-evaluated.
	//Tuples should speed up expression evaluation by only updating the appropriate branches.
	(int, int) position := (floor, location);
	
	//Notifications are a key ingredient to KVO. If the value of the position property is changed,
	//a notification is generated which can be cought and reacted upon by the class.
	- void @position.willChange
	{
		//Since values in tuples are anonymous, i.e. they are not associated with a name, we either
		//have to point a named tuple at the position, or access the values by index.
		
		//The following line is called an alias. Aliases are a nice tool if some value of interest
		//is nested and hard to access, but is used frequently. The identifiers f and l will be
		//available after this line and resolve to floor and location.
		(f, l) -> @new;
		int newFloor = f;
		int newLocation = l;
		
		//The following line is simpler if you don't intend to do much with a tuple. @new is the new
		//value that is to be assigned to position. The hashtag # is used to access the values of a
		//tuple by their index.
		int newFloor = @new.#1;
		int newLocation = @new.#2;
	}
	
	- void changePosition
	{
		//The following line sets the item floor to 10 by creating a new tuple and using the current
		//location of the item. This will change the position in its entirety and will trigger a
		//«position.willChange» notification, hence the previous function will be called.
		this.position = (10, this.location);
		pos = "Hello World\" whazup";
		
		//The following line doesn't change the position to a new tuple, but accesses the position
		//tuple and changes its first value, which is the floor. This will trigger a
		//«willChange» notification to be sent to the tuple that is changed, which forwards the
		//notification to the position property.
		this.position.#1 = 10;
	}
}

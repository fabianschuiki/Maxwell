/* Automatically generated by ast-gen. DO NOT MODIFY. */
#include "maxwell/ast/nodes/NativeType.hpp"
#include "maxwell/ast/Coder.hpp"
#include <cstdio>
#include <sstream>
#include <stdexcept>
using ast::NativeType;
using ast::NodePtr;
using ast::NodeVector;

NativeType::NativeType() : Node() {}

bool NativeType::isKindOf(Kind k) {
	if (Node::isKindOf(k)) return true;
	return k == kNativeType;
}

bool NativeType::implements(Interface i) {
	if (Node::implements(i)) return true;
	return false;
}

NodePtr NativeType::copy() {
	Ptr c (new NativeType);
	Node::copy(this->segments, c->segments);
	return c;
}

bool NativeType::equalTo(const NodePtr& o) {
	const shared_ptr<NativeType>& other = boost::dynamic_pointer_cast<NativeType>(o);
	if (!other) return false;
	if (!equal(this->segments, other->segments)) return false;
	return true;
}

std::string NativeType::describe(int depth) {
	std::stringstream str, b;
	str << describeVector(segments);
	return str.str();
}


void NativeType::setSegments(const std::vector<std::string>& v) {
	if (!equal(v, segments)) {
		modify("segments");
		segments = v;
	}
}

const std::vector<std::string>& NativeType::getSegments(bool required) {
	const std::vector<std::string>& v = segments;
	return v;
}


void NativeType::encode(Encoder& e) {
	e.encode(this->segments);
}

void NativeType::decode(Decoder& d) {
	d.decode(this->segments);
}


void NativeType::updateHierarchyOfChildren() {
}

const NodePtr& NativeType::resolvePath(const std::string& path) {
	throw std::runtime_error("Node path '" + path + "' does not point to a node or array of nodes.");
}


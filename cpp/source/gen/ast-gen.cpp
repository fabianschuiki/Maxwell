/* Copyright © 2013 Fabian Schuiki */

/**
 * @file This tool generates the C++ header and source files for the abstract
 * syntax tree.
 */

#include "ast-def.hpp"

void makeTypesHeader(const boost::filesystem::path& output, const Builder& builder)
{
	boost::filesystem::path path = output;
	path /= "types.hpp";
	ofstream h(path.c_str());
	h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	h << "#pragma once\n\n";
	h << "namespace ast {\n\n";
	h << "/// Node kinds that may be used to test whether a Node is of a given subclass.\n";
	h << "typedef enum {";
	bool first = true;
	for (Builder::Nodes::const_iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		h << (first ? "\n" : ",\n");
		h << "\tk" << it->first;
		first = false;
	}
	h << "\n} Kind;\n";
	h << "\n} // namespace ast\n\n";
}

typedef set<string> NodeNames;
void generateFactoryBody(std::ostream& out, NodeNames names, int indent, string basePrefix = "")
{
	string pad(indent, '\t');

	// Extract the prefixes.
	string prefix;
	string commonPrefix = basePrefix;
	bool common = true;
	do {
		NodeNames newNames;
		NodeNames::iterator nambeg = names.begin();
		bool singleMatch = false;
		if ((*nambeg).size() == commonPrefix.size()) {
			newNames.insert(*nambeg);
			names.erase(nambeg);
			//cout << "one name equals common prefix " << commonPrefix << "\n";
			prefix = commonPrefix;
			singleMatch = true;
		} else {
			prefix = commonPrefix + (*nambeg)[commonPrefix.size()];
			//cout << "prefix " << prefix << "\n";
			for (NodeNames::iterator it = names.begin(); it != names.end();) {
				string name = *it;
				NodeNames::iterator tmpit = it;
				it++;
				if (name.size() < prefix.size() || name.substr(0, prefix.size()) != prefix)
					break;
				newNames.insert(name);
				names.erase(tmpit);
				//cout << "- adding " << name << "\n";
			}
		}
		if (names.empty() && common && !singleMatch) {
			commonPrefix = prefix;
			names = newNames;
			//cout << "all names consumed\n";
		} else {
			if (common) {
				common = false;
				out << pad << "// " << commonPrefix << ".*\n";
				out << pad << "if (size >= " << commonPrefix.size();
				for (int i = basePrefix.size(); i < commonPrefix.size(); i++) {
					out << " && name[" << i <<"] == '" << commonPrefix[i] << "'";
				}
				out << ") {\n";
			}
			//cout << "-> generating subbranch for " << commonPrefix << " with " << newNames.size() << " names, with " << names.size() << " names remaining\n";
			if (newNames.size() > 1 || (newNames.size() == 1 && !singleMatch)) {
				generateFactoryBody(out, newNames, indent + 1, commonPrefix);
			} else {
				string name = *newNames.begin();
				out << pad << "\t// " << name << "\n";
				out << pad << "\tif (size == " << name.size() << ") ";
				out << "return NodePtr(new " << name << ");\n";
			}
		}
	} while (!names.empty());
	if (!common) {
		out << pad << "}\n";
	}
	//cout << "common prefix = " << commonPrefix << "\n";
}

void makeNodesHeader(const boost::filesystem::path& output, const Builder& builder, const Headers& headerFileNames)
{
	boost::filesystem::path path = output;
	path /= "nodes.hpp";
	ofstream h(path.c_str());
	h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	h << "#pragma once\n#include <string>\n\n";
	for (Headers::const_iterator it = headerFileNames.begin(); it != headerFileNames.end(); it++) {
		h << "#include \"" << *it << "\"\n";
	}

	// Generate the node factory class.
	h << "\nnamespace ast {\n\n";
	h << "using std::string;\n\n";
	h << "/// Node factory.\n";
	h << "class NodeFactory\n{\npublic:\n";
	h << "\tstatic NodePtr make(const string& name)\n\t{\n";
	h << "\t\tsize_t size = name.size();\n";
	NodeNames names;
	for (Builder::Nodes::const_iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		names.insert(it->first);
	}
	generateFactoryBody(h, names, 2);
	h << "\t\tthrow std::runtime_error(\"Node class name '\" + name + \"' not known to NodeFactory.\");\n";
	h << "\t}\n";
	h << "};\n";
	h << "\n} // namespace ast\n\n";
}

typedef set<string> FieldNames;
void generateResolvePathBody(std::ostream& out, FieldNames names, const FieldNames& arrayFields, int indent, string basePrefix = "")
{
	string pad(indent, '\t');

	// Extract the prefixes.
	string prefix;
	string commonPrefix = basePrefix;
	bool common = true;
	do {
		NodeNames newNames;
		NodeNames::iterator nambeg = names.begin();
		bool singleMatch = false;
		if ((*nambeg).size() == commonPrefix.size()) {
			newNames.insert(*nambeg);
			names.erase(nambeg);
			prefix = commonPrefix;
			singleMatch = true;
		} else {
			prefix = commonPrefix + (*nambeg)[commonPrefix.size()];
			for (NodeNames::iterator it = names.begin(); it != names.end();) {
				string name = *it;
				NodeNames::iterator tmpit = it;
				it++;
				if (name.size() < prefix.size() || name.substr(0, prefix.size()) != prefix)
					break;
				newNames.insert(name);
				names.erase(tmpit);
			}
		}
		if (names.empty() && common && !singleMatch) {
			commonPrefix = prefix;
			names = newNames;
		} else {
			if (common) {
				common = false;
				out << pad << "// " << commonPrefix << ".*\n";
				out << pad << "if (";
				if (!commonPrefix.empty())
					out << "size >= " << commonPrefix.size();
				else
					out << "true";
				for (int i = basePrefix.size(); i < commonPrefix.size(); i++) {
					out << " && path[" << i <<"] == '" << commonPrefix[i] << "'";
				}
				out << ") {\n";
			}
			//cout << "-> generating subbranch for " << commonPrefix << " with " << newNames.size() << " names, with " << names.size() << " names remaining\n";
			if (newNames.size() > 1 || (newNames.size() == 1 && !singleMatch)) {
				generateResolvePathBody(out, newNames, arrayFields, indent + 1, commonPrefix);
			} else {
				string name = *newNames.begin();
				bool isArray = arrayFields.count(name);
				string upper = (char)toupper(name[0]) + name.substr(1);

				out << pad << "\t// " << name << "\n";
				out << pad << "\tif (size == " << name.size() << ") {\n";
				if (isArray) {
					out << pad << "\t\tthrow std::runtime_error(\"Path '\" + path + \"' refers to an array instead of a concrete array element.\");\n";
				} else {
					out << pad << "\t\treturn get" << upper << "();\n";	
				}
				out << pad << "\t} else if (path[" << name.size() << "] == '.') {\n";
				if (isArray) {
					out << pad << "\t\tsize_t dot = path.find(\".\", " << name.size() + 1 << ");\n";
					out << pad << "\t\tstring idx_str = path.substr(" << name.size() + 1 << ", dot);\n";
					out << pad << "\t\tint idx = atoi(idx_str.c_str());\n";
					out << pad << "\t\tconst NodeVector& a = get" << upper << "();\n";
					out << pad << "\t\tif (idx < 0 || idx >= a.size()) {\n";
					out << pad << "\t\t\tthrow std::runtime_error(\"Index into array '\" + path.substr(0, " << name.size() << ") + \"' is out of bounds.\");\n";
					out << pad << "\t\t}\n";
					out << pad << "\t\tif (dot == string::npos) {\n";
					out << pad << "\t\t\treturn a[idx];\n";
					out << pad << "\t\t} else {\n";
					out << pad << "\t\t\treturn a[idx]->resolvePath(path.substr(dot + 1));\n";
					out << pad << "\t\t}\n";
				} else {
					out << pad << "\t\treturn get" << upper << "()->resolvePath(path.substr(" << name.size() + 1 << "));\n";
				}
				out << pad << "\t}\n";
			}
		}
	} while (!names.empty());
	if (!common) {
		out << pad << "}\n";
	}
	//cout << "common prefix = " << commonPrefix << "\n";
}

int main(int argc, char *argv[])
{
	// Parse command line arguments.
	boost::filesystem::path output(".");
	if (argc >= 2) output = argv[1];

	// Create the output directory if required.
	if (!boost::filesystem::exists(output)) {
		cout << "Creating output directory " << output << endl;
		boost::filesystem::create_directory(output);
	}

	// Build the AST.
	Builder builder;
	buildAST(builder);

	// Generate the code for the nodes.
	Headers headerFileNames;
	for (Builder::Nodes::iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		const string &name = it->first;
		Node &node = it->second;
		cout << "- Generating \033[36;1m" << name << "\033[0m" << endl;
		string headerName = name + ".hpp";

		// Generate the header file.
		boost::filesystem::path hpath = output;
		hpath /= headerName;
		ofstream h(hpath.c_str());
		h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
		h << "#pragma once\n";
		h << "#include \"../Node.hpp\"\n";
		h << "#include \"../Coder.hpp\"\n";
		h << "#include <vector>\n#include <string>\n#include <sstream>\n#include <boost/smart_ptr.hpp>\n#include <stdexcept>\n\n";
		h << "namespace ast {\n\n";
		h << "using std::vector;\nusing std::string;\nusing std::stringstream;\nusing std::endl;\nusing std::runtime_error;\n\n";
		h << "class " << name << " : public Node\n{\n";

		h << "public:\n";
		h << "\t" << name << "() : Node() {}\n\n";
		h << "\tvirtual bool isKindOf(Kind k)\n\t{\n";
		h << "\t\tif (" << node.parent << "::isKindOf(k)) return true;\n";
		h << "\t\treturn k == k" << node.name << ";\n";
		h << "\t}\n\n";
		h << "\tvirtual string getClassName() const { return \"" << node.name << "\"; }\n\n";

		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			string ref = "const " + f.cpp_type + "&";
			string upper = f.name;
			if (!upper.empty()) upper[0] = toupper(upper[0]);
			h << "\tvoid set" << upper << "(" << ref << " v)\n\t{\n";

			vector<string> ifcomponents;
			string allowedNodes;
			string allowedInterfaces;
			for (int i = 0; i < f.allowedNodes.size(); i++) {
				ifcomponents.push_back("!v->isKindOf(k" + f.allowedNodes[i] + ")");
				if (!allowedNodes.empty()) allowedNodes += ", ";
				allowedNodes += f.allowedNodes[i];
			}
			if (!ifcomponents.empty()) {
				h << "\t\tif (v";
				for (int i = 0; i < ifcomponents.size(); i++) {
					h << " && " << ifcomponents[i];
				}
				h << ") {\n";
				h << "\t\t\tthrow runtime_error(\"'" << f.name << "' needs to be of kind {" << allowedNodes << "} or implement interface {" << allowedInterfaces << "}.\");\n";
				h << "\t\t}\n";
			}

			h << "\t\tif (v != " << f.name << ") {\n";
			h << "\t\t\tmodify();\n";
			h << "\t\t\t" << f.name << " = v;\n";
			if (f.ref) {
				h << "\t\t\t" << f.name << "_ref.clear();\n";
			}
			h << "\t\t}\n";
			h << "\t}\n";

			h << "\t" << ref << " get" << upper << "()\n\t{\n";
			if (f.ref) {
				h << "\tif (!" << f.name << "_ref.empty()) {\n";
				h << "\t\t" << f.name << " = resolveReference(" << f.name << "_ref);\n";
				h << "\t\t" << f.name << "_ref.clear();\n";
				h << "\t}\n";
			}
			h << "\t\treturn " << f.name << ";\n\t}\n\n";
		}

		// Generate the describe() function.
		h << "\tvirtual string describe(int depth = -1)\n\t{\n";
		h << "\t\tif (depth == 0) return \"" << name << "{…}\";\n";
		h << "\t\tstringstream str, b;\n";
		h << "\t\tstr << \"" << name << "{\";\n";
		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			if (f.isString) {
				h << "\t\tif (!this->"<<f.name<<".empty()) b << endl << \"  \\033[1m"<<f.name<<"\\033[0m = '\\033[33m\" << this->"<<f.name<<" << \"\\033[0m'\";\n";
			} else if (f.isNode) {
				h << "\t\tif (this->"<<f.name<<") b << endl << \"  \\033[1m"<<f.name<<"\\033[0m = \" << indent(this->"<<f.name<<"->describe(depth-1));\n";
			} else if (f.isArray) {
				h << "\t\tif (!this->"<<f.name<<".empty()) b << endl << \"  \\033[1m"<<f.name<<"\\033[0m = \" << indent(describeVector(this->"<<f.name<<", depth-1)) << \"\";\n";
			}
		}
		h << "\t\tstring bs = b.str();\n";
		h << "\t\tif (!bs.empty()) str << bs << endl;\n";
		h << "\t\tstr << \"}\";\n";
		h << "\t\treturn str.str();\n";
		h << "\t}\n\n";

		// Generate the encode() function.
		h << "\tvirtual void encode(Encoder& e)\n\t{\n";
		for (Node::Fields::iterator f = node.attributes.begin(); f != node.attributes.end(); f++) {
			h << "\t\te.encode(this->" << (*f).name;
			if ((*f).ref) h << ", &" << (*f).name << "_ref";
			h << ");\n";
		}
		h << "\t}\n\n";

		// Generate the decode() function.
		h << "\tvirtual void decode(Decoder& d)\n\t{\n";
		for (Node::Fields::iterator f = node.attributes.begin(); f != node.attributes.end(); f++) {
			h << "\t\td.decode(this->" << (*f).name;
			if ((*f).ref) h << ", &" << (*f).name << "_ref";
			h << ");\n";
		}
		h << "\t}\n\n";

		// Generate the updateHierarchy() function.
		h << "\tvirtual void updateHierarchy(const NodeId& id, const weak_ptr<Repository>& repository = weak_ptr<Repository>(), const weak_ptr<Node>& parent = weak_ptr<Node>())\n\t{\n";
		h << "\t\t" << node.parent << "::updateHierarchy(id, repository, parent);\n";
		h << "\t\tconst NodePtr& self(shared_from_this());\n";
		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			if (f.isNode) {
				h << "\t\tif (this->"<<f.name<<") this->"<<f.name<<"->updateHierarchy(id + \""<<f.name<<"\", repository, self);\n";
			} else if (f.isArray) {
				h << "\t\tfor (int i = 0; i < this->"<<f.name<<".size(); i++) {\n";
				h << "\t\t\tchar buf[32]; snprintf(buf, 31, \"%i\", i);\n";
				h << "\t\t\tthis->"<<f.name<<"[i]->updateHierarchy((id + \""<<f.name<<"\") + buf, repository, self);\n";
				h << "\t\t}\n";
			}
		}
		h << "\t}\n\n";

		// Generate the resolvePath() function.
		h << "\tvirtual const NodePtr& resolvePath(const string& path)\n\t{\n";
		FieldNames fields, arrayFields;
		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			if (f.isNode) {
				fields.insert(f.name);
			} else if (f.isArray) {
				fields.insert(f.name);
				arrayFields.insert(f.name);
			}
		}
		h << "\t\tsize_t size = path.size();\n";
		generateResolvePathBody(h, fields, arrayFields, 2);
		h << "\t\tthrow std::runtime_error(\"Node path '\" + path + \"' does not point to a node or array of nodes.\");\n";
		h << "\t}\n";

		h << "protected:\n";
		for (Node::Fields::iterator f = node.attributes.begin(); f != node.attributes.end(); f++) {
			h << "\t" << (*f).cpp_type << " " << (*f).name << ";\n";
			if ((*f).ref) h << "\tNodeId " << (*f).name << "_ref;\n";
		}

		h << "};\n\n";
		h << "} // namespace ast";
		headerFileNames.push_back(headerName);
	}

	// Generate the header file containing general typedefs.
	makeTypesHeader(output, builder);
	makeNodesHeader(output, builder, headerFileNames);

	// Generate the header file aggregating all AST things.
	boost::filesystem::path ahpath = output;
	ahpath /= "ast.hpp";
	ofstream ah(ahpath.c_str());
	ah << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	ah << "#pragma once\n\n";
	ah << "#include \"types.hpp\"\n";
	ah << "#include \"nodes.hpp\"\n";

	return 0;
}
\section{Miscellaneous}

This section acts as a placeholder for random information.

\subsection{Array Literals}

An array literal is a constant, static array defined in source code. It is not intended to be modified and supports only a rather simplistic interface:

\begin{itemize}
  \item get (index Int) -> A
  \item length -> Int
\end{itemize}

This corresponds to the \emph{ConstArray} interface, which declares a function to access individual elements, and a function to obtain the overall length of the array.


\subsection{Iterators}

An iterator is a structure which walks through elements of a collection; i.e. an array, set, map or string. Walking through a linear collection such as a vector array is simple, as the elements may be accessed by a continuously increasing index. In case of more complex structures, such as sets or maps, stepping from one element to another is not as simple anymore. Iterators provide a way to abstract this operation, allowing each collection to implement their most efficient iteration technique.

\begin{lstlisting}[float,caption=Iterator interface definition,label=iterator]
type Iterator interface {
	next (iterator * @) -> nil;
	get (iterator @) -> any;
	end (iterator @) -> Bool;
}
\end{lstlisting}

The language shall define an \emph{Iterator} interface as shown in listing \ref{iterator}. The \emph{next} function advances the iterator to the next element, or does nothing if the iterator went past the last element of its collection. The \emph{get} function provides access to the element the iterator is currently pointing at.


\section{Sequential Expressions aka Blocks}

Since everything is an expression in Maxwell, there are no statements. Blocks \lstinline|{ ... }| in classic C-like languages are statements, i.e. they describe a computational step and do not have a value. In Maxwell, blocks also have a return value, depending on the syntax used for their definition. The following possibilities exist:

\emph{Implicit return value}. In its simplest form, a block in Maxwell looks the same as in C. A list of semicolon-separated expressions enclosed in curly braces. The return value corresponds to the last statement in the block.
\lstinline|{ expr0; expr1; ... exprn; } = exprn;|

\emph{Explicit single return value}. The block expression may be prefixed by a return variable name which may be assigned a value inside the block body. The variable may be used like any other variable or function argument, and will be returned as the block's value.
\lstinline|r { ... r = exprn; ... } = r;|

\emph{Explicit tuple return value}. Instead of a single return variable, the block expression may define a tuple of variables that will be returned as value.
\lstinline|(r,s) { ... r = exprn; s = exprm; ... } = (r,s);|

Refer to listing \ref{lst:seqexp_example} for an example of each type of sequential expression.
\begin{lstlisting}[float,caption=Sequential Expression examples,label=lst:seqexp_example]
var a = { var k = 4; sqrt(k); };
var b = r { r = sqrt(4); };
var c = (r,s) { r = 2; s = r + 2; };

// a = 2, type Real
// b = 2, type Real
// c = (2,4), type (Real, Real)
\end{lstlisting}


\subsection{Future Work}
It might actually be possible to unify the definition of variables, function arguments and block return variables into one entity.

/* Copyright Â© 2013 Fabian Schuiki */

/**
 * @file This tool generates the C++ header and source files for the abstract
 * syntax tree.
 */
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <vector>
#include <boost/filesystem.hpp>

using std::cout;
using std::endl;
using std::string;
using std::map;
using std::ofstream;
using std::vector;

class Node
{
public:
	string name;
	string parent;

	struct Field {
		string name;
		string type;
		string cpp_type;
		bool isArray;
		bool isNode;
		vector<string> allowedNodes;
		vector<string> allowedInterfaces;
	};
	typedef vector<Field> Fields;
	Fields children, attributes;

	Node& child(string name, string type) { children.push_back(makeField(name, type)); return *this; }
	Node& attr(string name, string type) { attributes.push_back(makeField(name, type)); return *this; }

private:
	Field makeField(string name, string type)
	{
		Field f;
		f.name = name;
		f.type = type;
		f.isArray = false;
		f.isNode = false;
		if (type == "string") {
			f.cpp_type = "string";
		} else if (type.size() > 2 && type[0] == '[') {
			f.isArray = true;
			f.cpp_type = "vector<shared_ptr<Node> >";
		} else {
			f.isNode = true;
			f.cpp_type = "shared_ptr<Node>";
			f.allowedNodes.push_back(type);
		}
		return f;
	}
};

class Builder
{
public:
	Node& operator() (const string& nodeName, const string& parentName = "Node")
	{
		Node &n = nodes[nodeName];
		n.name = nodeName;
		n.parent = parentName;
		return n;
	}
	typedef map<string, Node> Nodes;
	Nodes nodes;
};

/**
 * This function generates all AST nodes. It is called by the main function
 * to build the AST before the nodes are generated.
 */
void buildAST(Builder &node)
{
	node("FunctionDefinition")
		.attr("name", "string")
		.attr("in", "FuncArgTuple")
		.attr("out", "FuncArgTuple")
		.attr("body", "FuncBody");

	node("FuncArgTuple")
		.attr("args", "[FuncArg]");
	node("FuncArg")
		.attr("name", "string")
		.attr("type", "string");

	node("FuncBody");
}

int main(int argc, char *argv[])
{
	// Parse command line arguments.
	boost::filesystem::path output(".");
	if (argc >= 2) output = argv[1];

	// Create the output directory if required.
	if (!boost::filesystem::exists(output)) {
		cout << "Creating output directory " << output << endl;
		boost::filesystem::create_directory(output);
	}

	// Build the AST.
	Builder builder;
	buildAST(builder);

	// Generate the code for the nodes.
	typedef vector<string> Headers;
	Headers headerFileNames;
	for (Builder::Nodes::iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		const string &name = it->first;
		Node &node = it->second;
		cout << "- Generating \033[36;1m" << name << "\033[0m" << endl;
		string headerName = name + ".hpp";

		// Generate the header file.
		boost::filesystem::path hpath = output;
		hpath /= headerName;
		ofstream h(hpath.c_str());
		h << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
		h << "#pragma once\n";
		h << "#include \"Node.hpp\"\n";
		h << "#include <vector>\n#include <string>\n#include <boost/smart_ptr.hpp>\n#include <stdexcept>\n\n";
		h << "namespace ast {\n\n";
		h << "using std::vector;\nusing std::string;\nusing boost::shared_ptr;\nusing std::runtime_error;\n\n";
		h << "class " << name << " : public Node\n{\n";

		h << "public:\n";
		h << "\t" << name << "() : Node() {}\n\n";
		h << "\tvirtual bool isKindOf(Kind k)\n\t{\n";
		h << "\t\tif (" << node.parent << "::isKindOf(k)) return true;\n";
		h << "\t\treturn k == k" << node.name << ";\n";
		h << "\t}\n\n";

		for (Node::Fields::iterator fit = node.attributes.begin(); fit != node.attributes.end(); fit++) {
			Node::Field& f = *fit;
			string ref = "const " + f.cpp_type + "&";
			string upper = f.name;
			if (!upper.empty()) upper[0] = toupper(upper[0]);
			h << "\tvoid set" << upper << "(" << ref << " v)\n\t{\n";

			vector<string> ifcomponents;
			string allowedNodes;
			string allowedInterfaces;
			for (int i = 0; i < f.allowedNodes.size(); i++) {
				ifcomponents.push_back("!v->isKindOf(k" + f.allowedNodes[i] + ")");
				if (!allowedNodes.empty()) allowedNodes += ", ";
				allowedNodes += f.allowedNodes[i];
			}
			if (!ifcomponents.empty()) {
				h << "\t\tif (v";
				for (int i = 0; i < ifcomponents.size(); i++) {
					h << " && " << ifcomponents[i];
				}
				h << ") {\n";
				h << "\t\t\tthrow std::runtime_error(\"'" << f.name << "' needs to be of kind {" << allowedNodes << "} or implement interface {" << allowedInterfaces << "}.\");\n";
				h << "\t\t}\n";
			}

			h << "\t\tif (v != " << f.name << ") {\n";
			h << "\t\t\tmodify();\n";
			h << "\t\t\t" << f.name << " = v;\n";
			h << "\t\t}\n";
			h << "\t}\n";

			h << "\t" << ref << " get" << upper << "()\n\t{\n";
			h << "\t\treturn " << f.name << ";\n\t}\n\n";
		}

		h << "protected:\n";
		for (Node::Fields::iterator f = node.attributes.begin(); f != node.attributes.end(); f++) {
			h << "\t" << (*f).cpp_type << " " << (*f).name << ";\n";
		}

		h << "};\n\n";
		h << "} // namespace ast";
		headerFileNames.push_back(headerName);
	}

	// Generate the header file aggregating all nodes.
	boost::filesystem::path ahpath = output;
	ahpath /= "ast.hpp";
	ofstream ah(ahpath.c_str());
	ah << "/* Automatically generated by ast-gen. DO NOT MODIFY. */\n";
	ah << "#pragma once\n\n";
	ah << "namespace ast {\n\n";
	ah << "/// Node kinds that may be used to test whether a Node is of a given subclass.\n";
	ah << "typedef enum {";
	bool first = true;
	for (Builder::Nodes::iterator it = builder.nodes.begin(); it != builder.nodes.end(); it++) {
		ah << (first ? "\n" : ",\n");
		ah << "\tk" << it->first;
		first = false;
	}
	ah << "\n} Kind;\n";
	ah << "\n} // namespace ast\n\n";
	for (Headers::iterator it = headerFileNames.begin(); it != headerFileNames.end(); it++) {
		ah << "#include \"" << *it << "\"\n";
	}

	return 0;
}
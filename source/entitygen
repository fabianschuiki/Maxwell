#!/usr/bin/php
<?php
/* Copyright © 2013 Fabian Schuiki
 * Generates entities according to the Entities.json file.*/

// Read the definitions.
$defs_file = __DIR__."/Entities.json";
if (!file_exists($defs_file)) {
	echo "definitions file $defs_file does not exist\n";
	exit(1);
}
$defs = json_decode(file_get_contents($defs_file));
if (!$defs) {
	echo "unable to read definitions, JSON error ".json_last_error()."\n";
	exit(1);
}

// Create the output directory if required.
$dir = __DIR__."/Objects";
if (!file_exists($dir)) {
	if (!mkdir($dir)) {
		echo "unable to make output directory $dir\n";
		exit(1);
	}
}

// General purpose functions.
function makeInterfaceName($n)
{
	return str_replace(" ", "", ucwords(str_replace("_", " ", $n)))."Interface";
}

function processType($t)
{
	return str_replace(
		array(".", "array", "ref"),
		array("\\", "\\RepositoryObjectArray", "\\RepositoryObjectReference"),
		$t);
}

// Create an interface file for each interface.
$interface_defs = $defs->interfaces;
foreach ($interface_defs as $name => $def)
{
	$interfaceName = makeInterfaceName($name);

	// Analyse types.
	$canonicalProperties = array();
	foreach ($def as $i => $property) {
		if (!preg_match('/(([^\s]+)\s+)?(\w+)/', $property, $m)) {
			echo "invalid property \"$property\"\n";
			exit(1);
		}
		$p = new stdClass;
		$p->name = $m[3];
		$p->type = processType($m[2]);
		$canonicalProperties[$i] = $p;
	}

	// Create the accessors for each property.
	$body = "";
	foreach ($canonicalProperties as $property) {
		$lcname = $property->name;
		$ucname = ucfirst($lcname);
		$scalarType = (!$property->type || $property->type == "string");

		// SETTER
		$body .= "public function set{$ucname}(";
		if (!$scalarType) $body .= $property->type." ";
		$body .= "\$".$lcname;
		if (!$scalarType) $body .= " = null";
		$body .= ", \$notify = true);\n";

		// GETTER
		$body .= "public function get{$ucname}(\$enforce = true);\n\n";
	}

	// Generate the class creation code.
	$output = "<?php\n/* Copyright © 2013 Fabian Schuiki.\n * Automatically generated interface. */\n";
	$output .= "namespace Objects;\n\n";
	$output .= "interface $interfaceName\n{\n\t";
	$output .= str_replace("\n", "\n\t", trim($body));
	$output .= "\n}";

	// Store the code to disk.
	$file = $dir."/$interfaceName.php";
	file_put_contents($file, $output);
}

// Create an entity for each entity.
$entity_defs = $defs->entities;
foreach ($entity_defs as $name => $def)
{
	// Strip out the magic properties.
	$implements = (isset($def->implements) ? $def->implements : array());
	unset($def->implements);
	if (is_array($implements))
		$interfaces = $implements;
	else
		$interfaces = array($implements);
	$superclass = (isset($def->root) && $def->root === true ? "\\RepositoryRootObject" : "\\RepositoryNodeObject");
	if (isset($def->extends))
		$superclass = $def->extends;
	unset($def->extends);
	unset($def->root);

	// Generate the fragments.
	$afragments = array();
	$afragments[] = 
		"protected \$parent = null;\n".
		"protected \$parent_key = null;\n".
		"protected \$parent_fragment = null;";
	$bfragments = array();
	$propertiesByFragment = array();
	foreach ($def as $fragmentName => $properties) {
		$prop_dirty  = "{$fragmentName}_dirty";
		$prop_loaded = "{$fragmentName}_loaded";

		$afragment  = "// $fragmentName fragment\n";
		$afragment .= "public \$$prop_dirty  = false;\n";
		$afragment .= "public \$$prop_loaded = true;";

		// Resolve interfaces.
		$canonicalProperties = array();
		if (!is_array($properties)) {
			echo "Invalid list of properties in {$name}.{$fragmentName}\n";
			exit(1);
		}
		foreach ($properties as $property) {
			if ($property[0] === "@") {
				$interfaceName = substr($property, 1);
				if (!isset($interface_defs->$interfaceName)) {
					echo "unknown interface \"$interfaceName\" in fragment \"$fragmentName\" of $name\n";
					exit(1);
				}
				foreach ($interface_defs->$interfaceName as $p)
					$canonicalProperties[] = $p;
				$interfaces[] = makeInterfaceName($interfaceName);
			} else {
				$canonicalProperties[] = $property;
			}
		}

		// Analyse types.
		foreach ($canonicalProperties as $i => $property) {
			if (!preg_match('/(([^\s]+)\s+)?(\w+)/', $property, $m)) {
				echo "invalid property \"$property\"\n";
				exit(1);
			}
			$p = new stdClass;
			$p->name = $m[3];
			$p->type = processType($m[2]);
			$canonicalProperties[$i] = $p;
		}
		$propertiesByFragment[$fragmentName] = $canonicalProperties;

		// Create a property statement for each property.
		foreach ($canonicalProperties as $property) {
			$afragment .= "\nprotected \${$property->name};";
		}

		// Create the accessors for each property.
		$bfragment = "";
		foreach ($canonicalProperties as $property) {
			$lcname = $property->name;
			$ucname = ucfirst($lcname);
			$scalarType = (!$property->type || $property->type == "string");

			// SETTER
			$bfragment .= "public function set{$ucname}(";
			if (!$scalarType) $bfragment .= $property->type." ";
			$bfragment .= "\$".$lcname;
			if (!$scalarType) $bfragment .= " = null";
			$bfragment .= ", \$notify = true)\n{";
			
			// Perform a data type check.
			if ($property->type == "string") {
				$bfragment .= "
	if (!is_string(\$$lcname)) {
		throw new \\InvalidArgumentException(\"$lcname needs to be a string\");
	}";
			}

			// Store the value.
			$bfragment .= "
	if (\$this->$lcname !== \$$lcname) {
		if (!\$this->$prop_loaded) {
			\$this->loadFragment('$fragmentName');
		}";
			if (!$scalarType) $bfragment .= "\n\t\tif (\$this->$lcname instanceof \\RepositoryObjectParentInterface) \$this->{$lcname}->setParent(null);";
			$bfragment .= "\n\t\t\$this->$lcname = \$$lcname;";
			if (!$scalarType) $bfragment .= "\n\t\tif (\$$lcname instanceof \\RepositoryObjectParentInterface) \${$lcname}->setParent(\$this, \"$lcname\", \"$fragmentName\");";
			$bfragment .= "\n\t\tif (\$notify) {"
				//."\n\t\t\t\$this->$prop_dirty = true;"
				."\n\t\t\t\$this->notifyFragmentDirty('$fragmentName');"
				."\n\t\t}"
				."\n\t}";
			$bfragment .= "\n}\n";

			// GETTER
			$bfragment .= "public function get{$ucname}(\$enforce = true)\n{";
			$bfragment .= 
				"\n\tif (!\$this->$prop_loaded) {".
				"\n\t\t\$this->loadFragment('$fragmentName');".
				"\n\t}".
				"\n\tif (\$enforce && \$this->$lcname === null) {".
				"\n\t\tthrow new \\RuntimeException(\"Object {\$this->getId()} expected to have non-null $lcname.\");".
				"\n\t}".
				"\n\treturn \$this->$lcname;";
			$bfragment .= "\n}\n\n";
		}

		// Store the generated fragment.
		$afragments[] = $afragment;
		$bfragments[] = trim($bfragment);
	}

	// Assemble the general interface.
	$general = array();
	$general[] = "public function setParent(\\RepositoryObject \$parent = null, \$key = null, \$fragment = null)\n".
		"{\n".
		"\t\$this->parent = \$parent;\n".
		"\t\$this->parent_key = \$key;\n".
		"\t\$this->parent_fragment = \$fragment;\n".
		"}";
	$fragNames = array_map(function($n){ return "\"$n\""; }, array_keys(get_object_vars($def)));
	$general[] = "public function getFragmentNames()\n{\n\treturn array(".implode(",", $fragNames).");\n}";
	$gf = "public function getFragment(\$name)\n{\n\tswitch (\$name) {";
	foreach (array_keys(get_object_vars($def)) as $fragmentName) {
		$ps = array();
		foreach ($propertiesByFragment[$fragmentName] as $p) {
			$ps[] = "\n\t\t\tarray(\"name\" => \"{$p->name}\", \"type\" => \"{$p->type}\")";
		}
		$gf .= "\n\t\tcase \"$fragmentName\": return array(".implode(", ", $ps).");";
	}
	$gf .= "\n\t}\n\tthrow new \\RuntimeException(\"Fragment \$name does not exist.\");\n}";
	$general[] = $gf;
	$general[] = "public function getClass()\n{\n\treturn \"$name\";\n}";

	// Assemble the class body.
	$body  = "/* PROPERTIES */\n".implode("\n\n", $afragments)."\n\n\n";
	$body .= "/* GENERAL */\n".implode("\n\n", $general)."\n\n\n";
	$body .= "/* ACCESSORS */\n".implode("\n\n", $bfragments);

	// Generate the class creation code.
	$output = "<?php\n/* Copyright © 2013 Fabian Schuiki.\n * Automatically generated entity. */\n";
	$output .= "namespace Objects;\n\n";
	$output .= "class $name extends $superclass";
	if (count($interfaces))
		$output .= " implements ".implode(", ", $interfaces);
	$output .= "\n{\n\t";
	$output .= str_replace("\n", "\n\t", trim($body));
	$output .= "\n}";

	// Store the code to disk.
	$file = $dir."/$name.php";
	file_put_contents($file, $output);
}
/* Copyright (c) 2014 Fabian Schuiki */
#include "Packager.hpp"
#include "Packager-detail.hpp"
#include <algorithm>
#include <iostream>
using namespace backendc;


/** Sorting function that returns true if is to be placed before b according
 * to their order values. */
static bool sortFragment(Fragment* a, Fragment* b)
{
	return a->order > b->order;
}

/** Distributes the %fragments into %groups, sorting them according to their
 * order value and compiles a list of groups each group depends on. */
void Packager::group()
{
	for (std::map<std::string,Fragment*>::iterator i = fragments.begin(); i != fragments.end(); i++) {
		const std::string& gn = i->second->group;

		// Lookup the group for this fragment, or create one if it doesn't
		// yet exist.
		Group *g;
		std::map<std::string,Group*>::iterator k = groups.find(gn);
		if (k == groups.end()) {
			g = new Group;
			g->name = gn;
			groups.insert(std::pair<std::string,Group*>(gn,g));
		} else {
			g = k->second;
		}

		// Add this fragment to the group.
		g->frags.push_back(i->second);
	}

	// For every group, compile a list of other groups it depends on. These
	// dependencies are generated by fragments which have a dependency that is
	// not in the same group. Also, sort the fragments desceding by order.
	for (std::map<std::string,Group*>::iterator i = groups.begin(); i != groups.end(); i++) {
		std::set<std::string> used;
		i->second->deps.clear();
		for (std::vector<Fragment*>::iterator k = i->second->frags.begin(); k != i->second->frags.end(); k++) {
			for (std::vector<Dependency>::iterator l = (*k)->deps.begin(); l != (*k)->deps.end(); l++) {
				const std::string& gn = l->frag->group;
				if (l->after && gn != i->first && !used.count(gn)) {
					i->second->deps.push_back(groups[gn]);
					used.insert(gn);
				}
			}
		}

		std::sort(i->second->frags.begin(), i->second->frags.end(), sortFragment);
	}
}

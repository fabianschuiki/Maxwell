/* Automatically generated by ast-gen. DO NOT MODIFY. */
#pragma once
#include <string>

#include "BinaryOpExpr.hpp"
#include "CallArg.hpp"
#include "CallCandidate.hpp"
#include "CallCandidateArg.hpp"
#include "CallExpr.hpp"
#include "CallExprArg.hpp"
#include "DefinedType.hpp"
#include "ExprStmt.hpp"
#include "FuncArg.hpp"
#include "FuncBody.hpp"
#include "FuncDef.hpp"
#include "FuncType.hpp"
#include "GenericType.hpp"
#include "IdentifierExpr.hpp"
#include "InvalidType.hpp"
#include "MemberAccessExpr.hpp"
#include "NamedTypeExpr.hpp"
#include "TupleType.hpp"
#include "TupleTypeArg.hpp"
#include "TupleTypeExpr.hpp"
#include "TupleTypeExprArg.hpp"
#include "TypeDef.hpp"
#include "TypeSet.hpp"
#include "UnaryOpExpr.hpp"
#include "UnionType.hpp"
#include "UnionTypeExpr.hpp"
#include "VarDefExpr.hpp"

namespace ast {

using std::string;

/// Node factory.
class NodeFactory
{
public:
	static NodePtr make(const string& name)
	{
		size_t size = name.size();
		// .*
		if (true) {
			// BinaryOpExpr.*
			if (size >= 12 && name[0] == 'B' && name[1] == 'i' && name[2] == 'n' && name[3] == 'a' && name[4] == 'r' && name[5] == 'y' && name[6] == 'O' && name[7] == 'p' && name[8] == 'E' && name[9] == 'x' && name[10] == 'p' && name[11] == 'r') {
				// BinaryOpExpr
				if (size == 12) return NodePtr(new BinaryOpExpr);
			}
			// Call.*
			if (size >= 4 && name[0] == 'C' && name[1] == 'a' && name[2] == 'l' && name[3] == 'l') {
				// CallArg.*
				if (size >= 7 && name[4] == 'A' && name[5] == 'r' && name[6] == 'g') {
					// CallArg
					if (size == 7) return NodePtr(new CallArg);
				}
				// CallCandidate.*
				if (size >= 13 && name[4] == 'C' && name[5] == 'a' && name[6] == 'n' && name[7] == 'd' && name[8] == 'i' && name[9] == 'd' && name[10] == 'a' && name[11] == 't' && name[12] == 'e') {
					// CallCandidate
					if (size == 13) return NodePtr(new CallCandidate);
					// CallCandidateArg.*
					if (size >= 16 && name[13] == 'A' && name[14] == 'r' && name[15] == 'g') {
						// CallCandidateArg
						if (size == 16) return NodePtr(new CallCandidateArg);
					}
				}
				// CallExpr.*
				if (size >= 8 && name[4] == 'E' && name[5] == 'x' && name[6] == 'p' && name[7] == 'r') {
					// CallExpr
					if (size == 8) return NodePtr(new CallExpr);
					// CallExprArg.*
					if (size >= 11 && name[8] == 'A' && name[9] == 'r' && name[10] == 'g') {
						// CallExprArg
						if (size == 11) return NodePtr(new CallExprArg);
					}
				}
			}
			// DefinedType.*
			if (size >= 11 && name[0] == 'D' && name[1] == 'e' && name[2] == 'f' && name[3] == 'i' && name[4] == 'n' && name[5] == 'e' && name[6] == 'd' && name[7] == 'T' && name[8] == 'y' && name[9] == 'p' && name[10] == 'e') {
				// DefinedType
				if (size == 11) return NodePtr(new DefinedType);
			}
			// ExprStmt.*
			if (size >= 8 && name[0] == 'E' && name[1] == 'x' && name[2] == 'p' && name[3] == 'r' && name[4] == 'S' && name[5] == 't' && name[6] == 'm' && name[7] == 't') {
				// ExprStmt
				if (size == 8) return NodePtr(new ExprStmt);
			}
			// Func.*
			if (size >= 4 && name[0] == 'F' && name[1] == 'u' && name[2] == 'n' && name[3] == 'c') {
				// FuncArg.*
				if (size >= 7 && name[4] == 'A' && name[5] == 'r' && name[6] == 'g') {
					// FuncArg
					if (size == 7) return NodePtr(new FuncArg);
				}
				// FuncBody.*
				if (size >= 8 && name[4] == 'B' && name[5] == 'o' && name[6] == 'd' && name[7] == 'y') {
					// FuncBody
					if (size == 8) return NodePtr(new FuncBody);
				}
				// FuncDef.*
				if (size >= 7 && name[4] == 'D' && name[5] == 'e' && name[6] == 'f') {
					// FuncDef
					if (size == 7) return NodePtr(new FuncDef);
				}
				// FuncType.*
				if (size >= 8 && name[4] == 'T' && name[5] == 'y' && name[6] == 'p' && name[7] == 'e') {
					// FuncType
					if (size == 8) return NodePtr(new FuncType);
				}
			}
			// GenericType.*
			if (size >= 11 && name[0] == 'G' && name[1] == 'e' && name[2] == 'n' && name[3] == 'e' && name[4] == 'r' && name[5] == 'i' && name[6] == 'c' && name[7] == 'T' && name[8] == 'y' && name[9] == 'p' && name[10] == 'e') {
				// GenericType
				if (size == 11) return NodePtr(new GenericType);
			}
			// I.*
			if (size >= 1 && name[0] == 'I') {
				// IdentifierExpr.*
				if (size >= 14 && name[1] == 'd' && name[2] == 'e' && name[3] == 'n' && name[4] == 't' && name[5] == 'i' && name[6] == 'f' && name[7] == 'i' && name[8] == 'e' && name[9] == 'r' && name[10] == 'E' && name[11] == 'x' && name[12] == 'p' && name[13] == 'r') {
					// IdentifierExpr
					if (size == 14) return NodePtr(new IdentifierExpr);
				}
				// InvalidType.*
				if (size >= 11 && name[1] == 'n' && name[2] == 'v' && name[3] == 'a' && name[4] == 'l' && name[5] == 'i' && name[6] == 'd' && name[7] == 'T' && name[8] == 'y' && name[9] == 'p' && name[10] == 'e') {
					// InvalidType
					if (size == 11) return NodePtr(new InvalidType);
				}
			}
			// MemberAccessExpr.*
			if (size >= 16 && name[0] == 'M' && name[1] == 'e' && name[2] == 'm' && name[3] == 'b' && name[4] == 'e' && name[5] == 'r' && name[6] == 'A' && name[7] == 'c' && name[8] == 'c' && name[9] == 'e' && name[10] == 's' && name[11] == 's' && name[12] == 'E' && name[13] == 'x' && name[14] == 'p' && name[15] == 'r') {
				// MemberAccessExpr
				if (size == 16) return NodePtr(new MemberAccessExpr);
			}
			// NamedTypeExpr.*
			if (size >= 13 && name[0] == 'N' && name[1] == 'a' && name[2] == 'm' && name[3] == 'e' && name[4] == 'd' && name[5] == 'T' && name[6] == 'y' && name[7] == 'p' && name[8] == 'e' && name[9] == 'E' && name[10] == 'x' && name[11] == 'p' && name[12] == 'r') {
				// NamedTypeExpr
				if (size == 13) return NodePtr(new NamedTypeExpr);
			}
			// T.*
			if (size >= 1 && name[0] == 'T') {
				// TupleType.*
				if (size >= 9 && name[1] == 'u' && name[2] == 'p' && name[3] == 'l' && name[4] == 'e' && name[5] == 'T' && name[6] == 'y' && name[7] == 'p' && name[8] == 'e') {
					// TupleType
					if (size == 9) return NodePtr(new TupleType);
					// TupleTypeArg.*
					if (size >= 12 && name[9] == 'A' && name[10] == 'r' && name[11] == 'g') {
						// TupleTypeArg
						if (size == 12) return NodePtr(new TupleTypeArg);
					}
					// TupleTypeExpr.*
					if (size >= 13 && name[9] == 'E' && name[10] == 'x' && name[11] == 'p' && name[12] == 'r') {
						// TupleTypeExpr
						if (size == 13) return NodePtr(new TupleTypeExpr);
						// TupleTypeExprArg.*
						if (size >= 16 && name[13] == 'A' && name[14] == 'r' && name[15] == 'g') {
							// TupleTypeExprArg
							if (size == 16) return NodePtr(new TupleTypeExprArg);
						}
					}
				}
				// Type.*
				if (size >= 4 && name[1] == 'y' && name[2] == 'p' && name[3] == 'e') {
					// TypeDef.*
					if (size >= 7 && name[4] == 'D' && name[5] == 'e' && name[6] == 'f') {
						// TypeDef
						if (size == 7) return NodePtr(new TypeDef);
					}
					// TypeSet.*
					if (size >= 7 && name[4] == 'S' && name[5] == 'e' && name[6] == 't') {
						// TypeSet
						if (size == 7) return NodePtr(new TypeSet);
					}
				}
			}
			// Un.*
			if (size >= 2 && name[0] == 'U' && name[1] == 'n') {
				// UnaryOpExpr.*
				if (size >= 11 && name[2] == 'a' && name[3] == 'r' && name[4] == 'y' && name[5] == 'O' && name[6] == 'p' && name[7] == 'E' && name[8] == 'x' && name[9] == 'p' && name[10] == 'r') {
					// UnaryOpExpr
					if (size == 11) return NodePtr(new UnaryOpExpr);
				}
				// UnionType.*
				if (size >= 9 && name[2] == 'i' && name[3] == 'o' && name[4] == 'n' && name[5] == 'T' && name[6] == 'y' && name[7] == 'p' && name[8] == 'e') {
					// UnionType
					if (size == 9) return NodePtr(new UnionType);
					// UnionTypeExpr.*
					if (size >= 13 && name[9] == 'E' && name[10] == 'x' && name[11] == 'p' && name[12] == 'r') {
						// UnionTypeExpr
						if (size == 13) return NodePtr(new UnionTypeExpr);
					}
				}
			}
			// VarDefExpr.*
			if (size >= 10 && name[0] == 'V' && name[1] == 'a' && name[2] == 'r' && name[3] == 'D' && name[4] == 'e' && name[5] == 'f' && name[6] == 'E' && name[7] == 'x' && name[8] == 'p' && name[9] == 'r') {
				// VarDefExpr
				if (size == 10) return NodePtr(new VarDefExpr);
			}
		}
		throw std::runtime_error("Node class name '" + name + "' not known to NodeFactory.");
	}
};

} // namespace ast


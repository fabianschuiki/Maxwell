<?php
namespace Driver;
use Store\Manager;
use IssueList;
use Source\File;
use Entity;
use Compiler\CodePair;
use Compiler\Snippet;

class Compiler
{
	protected $entityIDs;
	
	public function __construct()
	{
		$this->entityIDs = array();
	}
	
	public function addEntityID($e) { $this->entityIDs[] = $e; }
	public function addEntityIDs(array $e) { $this->entityIDs = array_merge($this->entityIDs, $e); }
	public function getEntityIDs() { return $this->entityIDs; }
	
	public function run()
	{
		$manager = Manager::get();
		$entityStore = $manager->getEntityStore();
		$codeStore   = $manager->getCodeStore();
		$issues = IssueList::get();
		
		$precompileIDs = $this->entityIDs;
		$precompiled = array();
		$compileIDs = array();
		$aggregateIDs = array();
		while (count($precompileIDs) && !$issues->isFatal())
		{
			//Fetch the entity we're supposed to precompile.
			$entityID = array_shift($precompileIDs);
			$entity = $entityStore->getEntity($entityID);
			echo "precompiling {$entity->getID()} ".vartype($entity)."\n";
			
			//Decide the entity names.
			$this->calculateEntityNames($entity);
			
			//Mark this entity as to be compiled if it isn't generic.
			array_push($precompiled, $entityID);
			if (!$this->isEntityGeneric($entity)) {
				array_push($compileIDs, $entityID);
			} else {
				echo " -> not compiling generic entity $entityID\n";
			}
			
			//Compile this entity's known entities.
			foreach ($entity->getKnownEntities() as $known) {
				if (!in_array($known->getID(), $precompiled, true) && !in_array($known->getID(), $precompileIDs, true)) {
					array_push($precompileIDs, $known->getID());
				}
			}
		}
		
		while (count($compileIDs) && !$issues->isFatal())
		{
			//Fetch the entity we're supposed to compile.
			$entityID = array_shift($compileIDs);
			$entity = $entityStore->getEntity($entityID);
			echo "compiling {$entity->getID()} ".vartype($entity)."\n";
			
			//Prepare entity type information.
			$this->calculateEntityTypes($entity);
			if ($issues->isFatal()) break;
			
			//Generate code.
			if (!$entity instanceof \Entity\ExternalDeclaration) {
				$pair = $this->generateRootCodePair($entity);
				if ($issues->isFatal()) break;
				$codeStore->persistCode($entityID, $pair);
			}
			array_push($aggregateIDs, $entityID);
		}

		// Sort the aggregate IDs into files.
		$aggregateFiles = array();
		$externals = array();
		foreach ($aggregateIDs as $id) {
			$entity = $entityStore->getEntity($id);
			$aggregateFiles[$entity->getFile()->getPath()][] = $id;
			$externals[$id] = array();
			foreach ($entity->getReferencedEntities() as $e) {
				if (!$this->isEntityGeneric($e))
					$externals[$id][] = $e->getID();
			}
		}

		// Create the aggregate output files.
		$preamble = "/* This file was automatically generated by the Maxwell compiler on ".date("c").". */";
		foreach ($aggregateFiles as $name => $ids) {
			echo "aggregating $name\n";
			$basename = preg_replace('/\.[^\.]*$/sm', "", $name);
			$includes = array();
			$declarations = array('a' => array(), 'b' => array());
			$definitions = array();
			$externalDeclarations = array('a' => array(), 'b' => array());
			$referencedEntities = array();
			foreach ($ids as $id) {
				$base = "/tmp/$id";
				if (!file_exists("$base.inc.h"))
					continue;
				$includes[] = trim(file_get_contents("$base.inc.h"));
				$declarations['a'][] = trim(file_get_contents("$base.decl-a.c"));
				$declarations['b'][] = trim(file_get_contents("$base.decl-b.c"));
				$definitions['a'][] = trim(file_get_contents("$base.def-a.c"));
				$definitions['b'][] = trim(file_get_contents("$base.def-b.c"));
				//$externalDeclarations[] = "// external declarations for $id";
				$referencedEntities = array_merge($referencedEntities, $externals[$id]);
			}

			// Gather external declarations.
			$referencedEntities = array_map(function($id){
					preg_match('/[^\.]*/sm', $id, $matches);
					return $matches[0];
				}, $referencedEntities);
			$externalEntityIDs = array_diff(array_unique($referencedEntities), $ids);
			foreach ($externalEntityIDs as $id) {
				$da = "/tmp/$id.decl-a.c";
				$db = "/tmp/$id.decl-b.c";
				if (file_exists($da)) $externalDeclarations['a'][] = trim(file_get_contents($da));
				if (file_exists($db)) $externalDeclarations['b'][] = trim(file_get_contents($db));
			}

			$includes = array_filter($includes);
			$declarations['a'] = array_filter($declarations['a']);
			$declarations['b'] = array_filter($declarations['b']);
			$definitions['a'] = array_filter($definitions['a']);
			$definitions['b'] = array_filter($definitions['b']);
			$externalDeclarations['a'] = array_filter($externalDeclarations['a']);
			$externalDeclarations['b'] = array_filter($externalDeclarations['b']);

			// Gather external C functions used.
			$externalIncludes = array();
			foreach ($entityStore->getEntity($id)->getKnownEntities() as $entity) {
				if ($entity instanceof Entity\ExternalDeclaration) {
					$externalIncludes[] = $entity->getName();
				}
			}
			$externalIncludes = array_unique($externalIncludes);

			// Generate the files.
			$includes_flat             = implode("\n", $includes);
			$declarations_flat['a']    = implode("\n", $declarations['a']);
			$declarations_flat['b']    = implode("\n", $declarations['b']);
			$definitions_flat['a']     = implode("\n\n", $definitions['a']);
			$definitions_flat['b']     = implode("\n\n", $definitions['b']);
			$externalDeclarations_flat['a'] = implode("\n", $externalDeclarations['a']);
			$externalDeclarations_flat['b'] = implode("\n", $externalDeclarations['b']);

			$hcomps = array();
			if (strlen($includes_flat)) $hcomps[] = $includes_flat;
			if (strlen($externalDeclarations_flat['a'])) $hcomps[] = $externalDeclarations_flat['a'];
			if (strlen($externalDeclarations_flat['b'])) $hcomps[] = $externalDeclarations_flat['b'];
			if (strlen($declarations_flat['a'])) $hcomps[] = $declarations_flat['a'];
			if (strlen($declarations_flat['b'])) $hcomps[] = $declarations_flat['b'];
			$hfile = "$preamble\n#pragma once\n\n".implode("\n\n", $hcomps);

			$ccomps = array();
			if (strlen($declarations_flat['a'])) $ccomps[] = $declarations_flat['a'];
			if (strlen($declarations_flat['b'])) $ccomps[] = $declarations_flat['b'];
			if (strlen($definitions_flat['a'])) $ccomps[] = $definitions_flat['a'];
			if (strlen($definitions_flat['b'])) $ccomps[] = $definitions_flat['b'];
			$cfile = "$preamble\n";
			$cfile .= "#include \"".basename($basename).".h\"\n";
			/*foreach ($aggregateFiles as $aggregateName => $aggregateIDs) {
				if ($aggregateName === $name) continue;
				if (count(array_intersect($externalEntityIDs, $aggregateIDs))) {
					$aggregateRelative = $aggregateName; // TODO: relative path to this file's compilation destination required!
					$aggregateBasename = preg_replace('/\.[^\.]*$/sm', "", $aggregateRelative);
					$cfile .= "#include \"".$aggregateBasename.".h\"\n";
				}
			}*/
			foreach ($externalIncludes as $name) {
				$cfile .= "#include <$name>\n";
			}
			$cfile .= "\n".implode("\n\n", $ccomps);

			if (!file_exists(dirname("/tmp/$basename")))
				mkdir(dirname("/tmp/$basename"), 0777, true);
			file_put_contents("/tmp/$basename.h", $hfile);
			file_put_contents("/tmp/$basename.c", $cfile);
		}
	}
	
	/** Calculates the name of individual entities, as it will appear in the C file. */
	private function calculateEntityNames(Entity\Entity $entity)
	{
		foreach ($entity->getChildEntities() as $c) {
			$this->calculateEntityNames($c);
		}
		
		if ($entity instanceof Entity\Expr\VarDef) {
			$entity->compiler->setName($entity->getName());
		}
		if ($entity instanceof Entity\TypeDefinition) {
			$name = $entity->getName()."_".str_replace(".", "_", $entity->getID());
			$compiler = $entity->compiler;
			$compiler->setLocalName("struct $name");
			$compiler->setName("{$name}_t");
		}
		if ($entity instanceof Entity\Type\Member) {
			$compiler = $entity->compiler;
			$compiler->setName($entity->getName());
		}
		if ($entity instanceof Entity\FunctionDefinition) {
			$compiler = $entity->compiler;
			//this is quite a hack to distinguish function definitions in external {} statements and the standalone ones.
			//probably should be more sophisticated...
			if ($entity->getBody()) {
				$compiler->setName($entity->getName()."_".str_replace(".", "_", $entity->getID()));
			} else {
				$compiler->setName($entity->getName());
			}
		}
		if ($entity instanceof Entity\Func\Argument) {
			$entity->compiler->setName($entity->getName());
		}
	}
	
	private function calculateEntityTypes(Entity\Entity $entity)
	{
		foreach ($entity->getChildEntities() as $c) {
			$this->calculateEntityTypes($c);
		}
		
		if ($entity instanceof Entity\Expr\Expr) {
			$compiler = $entity->compiler;
			$type = $entity->analysis->type->inferred;
			
			if ($type instanceof \Type\Builtin) {
				$name = $type->getName();
				if ($name == "bool") $name = "char";
				$compiler->type->setName($name);
				$compiler->type->setPointerLevel(0);
			}
			else if ($type instanceof \Type\Defined) {
				$compiler->type->setName($type->getDefinition()->compiler->getLocalName());
				$compiler->type->setPointerLevel(1);
			}
			else if ($type instanceof \Type\Native) {
				$compiler->type->setName($type->getName());
				$compiler->type->setPointerLevel(0);
			}
			else {
				//throw new \exception("Type ".vartype($type)." of ".$entity->getInternalDescription()." cannot be compiled");
			}
		}
		if ($entity instanceof Entity\Type\Member || $entity instanceof Entity\Func\Argument) {
			$compiler = $entity->compiler;
			$type = $entity->analysis->type->inferred;
			if ($type instanceof \Type\Builtin) {
				$compiler->type->setName($type->getName());
				$compiler->type->setPointerLevel(0);
			}
			else if ($type instanceof \Type\Defined) {
				$compiler->type->setName($type->getDefinition()->compiler->getLocalName());
				$compiler->type->setPointerLevel(1);
			}
			else if ($type instanceof \Type\Native) {
				$compiler->type->setName($type->getName());
				$compiler->type->setPointerLevel(0);
			}
			else {
				throw new \exception("Type ".vartype($type)." of ".$entity->getInternalDescription()." cannot be compiled");
			}
		}
	}
	
	static public function indent($str)
	{
		return "\t".str_replace("\n", "\n\t", $str);
	}
	
	private function generateRootCodePair(Entity\RootEntity $entity)
	{
		$preamble = "/* This file was automatically generated by the Maxwell compiler. */";
		$snippet = $this->generateRootCode($entity);
		
		//Generate the header/source pair with the appropriate surroundings.
		$pair = new CodePair;
		$pair->header = "$preamble\n#pragma once\n\n";
		foreach ($entity->getKnownEntities() as $e) {
			if ($e instanceof \Entity\ExternalDeclaration) {
				$pair->header .= "#include <{$e->getName()}>\n";
			}
			if ($e instanceof \Entity\TypeDefinition) {
				$pair->header .= $e->compiler->getLocalName().";\n";
			}
		}
		$pair->header .= $snippet->publicHeader;
		
		//Include the headers of the known entities.
		$pair->source  = "$preamble\n#include \"{$entity->getID()}.h\"\n\n";
		$pair->source .= "//debug includes\n#include <stdlib.h>\n";
		foreach ($entity->getKnownEntities() as $e) {
			if ($e instanceof \Entity\ExternalDeclaration) {
				$pair->source .= "#include <{$e->getName()}>\n";
			} else if (!$this->isEntityGeneric($e)) {
				$pair->source .= "#include \"{$e->getID()}.h\"\n";
			}
		}
		$pair->source .= "\n";
		if ($snippet->privateHeader) {
			$pair->source .= $snippet->privateHeader."\n";
		}
		$pair->source .= $snippet->stmts;
		
		// Produce chunked output for the code aggregator.
		$basedir = "/tmp";
		$base = "$basedir/{$entity->getID()}";
		if (!file_exists(dirname($base))) {
			echo "Creating missing ".dirname($base)."\n";
			mkdir(dirname($base), 0777, true);
		}
		$declA = ($entity instanceof Entity\TypeDefinition ? $snippet->declarations : "");
		$declB = ($entity instanceof Entity\FunctionDefinition ? $snippet->declarations : "");
		$defA = ($entity instanceof Entity\TypeDefinition ? $snippet->definitions : "");
		$defB = ($entity instanceof Entity\FunctionDefinition ? $snippet->definitions : "");
		file_put_contents("$base.decl-a.c", $declA);
		file_put_contents("$base.decl-b.c", $declB);
		file_put_contents("$base.def-a.c", $defA);
		file_put_contents("$base.def-b.c", $defB);
		file_put_contents("$base.inc.h", $snippet->includes);

		return $pair;
	}
	
	private function generateRootCode(Entity\RootEntity $entity)
	{
		$snippet = new Snippet;
		if ($entity instanceof Entity\FunctionDefinition) {
			$output = $entity->getOutputArgs()->getArgs();
			if (count($output) > 1) {
				throw new \exception("Trying to compile function with more than one return value.");
			}
			if (count($output) == 0) {
				$declaration = "void ";
			} else {
				$declaration = $output[0]->compiler->type->getCType()." ";
			}
			$declaration .= $entity->compiler->getName();
			$declaration .= "(";
			
			$args = array();
			foreach ($entity->getInputArgs()->getArgs() as $arg) {
				$args[] = "{$arg->compiler->type->getCType()} {$arg->compiler->getName()}";
			}
			$declaration .= implode(", ", $args);
			
			$declaration .= ")";
			
			$block = $this->generateBlockCode($entity->getBody());

			$snippet->publicHeader .= "$declaration;\n";
			$snippet->stmts .= "$declaration\n{\n";
			foreach ($entity->getOutputArgs()->getArgs() as $arg) {
				$snippet->stmts .= "\t{$arg->compiler->type->getCType()} {$arg->compiler->getName()};\n";
			}
			$snippet->stmts .= static::indent(trim($block->stmts));
			foreach ($entity->getOutputArgs()->getArgs() as $arg) {
				$snippet->stmts .= "\n\treturn {$arg->compiler->getName()};";
			}
			$snippet->stmts .= "\n}\n";
			
			//If this is the function main.main, generate the proper entry point for the C program here as well.
			if ($entity->getName() == "main" && $entity->getPackageName() == "main") {
				$snippet->stmts .= "\n//main entry point\n";
				if (count($args) != 0) {
					IssueList::add('error', "Main function may not have any input arguments yet.", $entity);
				} else {
					$snippet->stmts .= "int main(int argc, char *argv[])\n{\n";
					$snippet->stmts .= "\t{$entity->compiler->getName()}();\n";
					$snippet->stmts .= "\treturn 0;\n}\n";
				}
			}
			
			$snippet->declarations .= $snippet->publicHeader;
			$snippet->definitions  .= $snippet->stmts;
		}
		if ($entity instanceof Entity\TypeDefinition) {
			$structName = $entity->compiler->getLocalName();
			$snippet->publicHeader = "typedef $structName {$entity->compiler->getName()};\n";
			$snippet->privateHeader = "$structName;\n";
			
			$body = "";
			foreach ($entity->getMembers() as $member) {
				$body .= "\t{$member->compiler->type->getCType()} {$member->compiler->getName()};\n";
			}
			
			//$snippet->stmts .= "$structName {\n$body};\n";
			$snippet->publicHeader .= "$structName {\n$body};\n";

			$snippet->declarations = $snippet->privateHeader;
			$snippet->definitions  = $snippet->publicHeader;
		}
		if ($entity instanceof Entity\ExternalDeclaration) {
			$snippet->publicHeader = "#include <{$entity->getName()}>\n";
			$snippet->includes = $snippet->publicHeader;
		}
		return $snippet;
	}
	
	private function generateBlockCode(Entity\Block $block)
	{
		$snippet = new Snippet;
		foreach ($block->getStmts() as $stmt) {
			$s = $this->generateStmtCode($stmt);
			$snippet->stmts .= $s->stmts;
		}
		return $snippet;
	}
	
	private function generateStmtCode(Entity\Stmt\Stmt $stmt)
	{
		$snippet = new Snippet;
		if ($stmt instanceof Entity\Stmt\Expr) {
			$s = $this->generateExprCode($stmt->getExpr());
			$snippet->stmts = $s->stmts;
			if ($s->expr && $s->exprRequired) $snippet->stmts .= $s->expr.";\n";
			$snippet->outerStmts = $s->outerStmts;
		}
		else if ($stmt instanceof Entity\Stmt\IfStmt) {
			$condition = $this->generateExprCode($stmt->getCondition());
			$block = $this->generateBlockCode($stmt->getBody());
			$snippet->stmts = $condition->stmts;
			$snippet->stmts .= "if ({$condition->expr}) {\n".static::indent(trim($block->stmts))."\n}";
			if ($else = $stmt->getElse()) {
				$elseCode = $this->generateStmtCode($else);
				$snippet->stmts .= " ".$elseCode->stmts;
			} else {
				$snippet->stmts .= "\n";
			}
		}
		else if ($stmt instanceof Entity\Stmt\ElseStmt) {
			$block = $this->generateBlockCode($stmt->getBody());
			$snippet->stmts = "else {\n".static::indent(trim($block->stmts))."\n}\n";
		}
		else if ($stmt instanceof Entity\Stmt\ForStmt) {
			$initial = ($stmt->getInitial() ? $this->generateExprCode($stmt->getInitial()) : null);
			$condition = $this->generateExprCode($stmt->getCondition());
			$increment = ($stmt->getIncrement() ? $this->generateExprCode($stmt->getIncrement()) : null);
			$block = $this->generateBlockCode($stmt->getBody());

			if ($initial) $snippet->stmts .= $initial->stmts;
			$snippet->stmts .= $condition->stmts;
			if ($increment) $snippet->stmts .= $increment->stmts;
			$snippet->stmts .= "for (";
			if ($initial) $snippet->stmts .= $initial->expr;
			$snippet->stmts .= "; {$condition->expr}; ";
			if ($increment) $snippet->stmts .= $increment->expr;
			$snippet->stmts .= ") {\n".static::indent(trim($block->stmts))."\n}\n";
		}
		else {
			throw new \exception("Unable to generate statement code for ".vartype($stmt));
		}
		return $snippet;
	}
	
	private function generateExprCode(Entity\Expr\Expr $expr)
	{
		$snippet = new Snippet;
		if ($expr instanceof Entity\Expr\VarDef) {
			$stmt = "{$expr->compiler->type->getCType()} {$expr->compiler->getName()}";
			if ($i = $expr->getInitial()) {
				$is = $this->generateExprCode($i);
				$stmt .= " = {$is->expr}";
				$snippet->stmts .= $is->stmts;
			}
			$stmt .= ";\n";
			$snippet->stmts .= $stmt;
			$snippet->expr = "{$expr->compiler->getName()}";
		}
		else if ($expr instanceof Entity\Expr\Operator\Binary) {
			$ls = $this->generateExprCode($expr->getLHS());
			$rs = $this->generateExprCode($expr->getRHS());
			$snippet->stmts .= $ls->stmts;
			$snippet->stmts .= $rs->stmts;
			$snippet->expr = "({$ls->expr} {$expr->getOperator()} {$rs->expr})";
			if ($expr->getOperator() == '=')
				$snippet->exprRequired = true;
		}
		else if ($expr instanceof Entity\Expr\Operator\Unary) {
			if ($expr->getOperand() instanceof Entity\Expr\Constant && $expr->getOperand()->getType() == 'string') {
				$snippet->expr = "'{$expr->getOperand()->getValue()}'";
			} else {
				$os = $this->generateExprCode($expr->getOperand());
				$snippet->stmts .= $os->stmts;
				$snippet->expr = "{$expr->getOperator()}{$os->expr}";
			}
		}
		else if ($expr instanceof Entity\Expr\Constant) {
			if ($expr->getType() == 'string') {
				$snippet->expr = "\"".$expr->getValue()."\"";
			} else {
				$snippet->expr = $expr->getValue();
			}
		}
		else if ($expr instanceof Entity\Expr\Identifier) {
			$snippet->expr = $expr->analysis->binding->target->compiler->getName();
		}
		else if ($expr instanceof Entity\Expr\MemberAccess) {
			$e = $this->generateExprCode($expr->getExpr());
			$op = ($expr->getExpr()->compiler->type->getPointerLevel() > 0 ? "->" : ".");
			$snippet->stmts .= $e->stmts;
			$snippet->expr = "{$e->expr}$op{$expr->getName()}";
		}
		else if ($expr instanceof Entity\Expr\NewOp) {
			$snippet->expr = "malloc(sizeof({$expr->analysis->type->inferred->getDefinition()->compiler->getLocalName()}))";
			$snippet->exprRequired = true;
		}
		else if ($expr instanceof Entity\Expr\Call) {
			$func = $expr->getCallee()->analysis->binding->target;
			$name = $func->compiler->getName();
			$args = array();
			foreach ($func->getInputArgs()->getArgs() as $i => $arg) {
				$callArg = null;
				foreach ($expr->getArgs()->getArgs() as $a) {
					if ($a->getName() == $arg->getName()) {
						$callArg = $a;
						break;
					}
				}
				if (!$callArg) {
					$callArgs = $expr->getArgs()->getArgs();
					if ($i < count($callArgs)) {
						$callArg = $callArgs[$i];
					} else {
						IssueList::add('error', "Function call is lacking argument '{$arg->getName()}'.", $expr, $arg);
					}
				}
				$as = $this->generateExprCode($callArg->getExpr());
				$snippet->stmts .= $as->stmts;
				$args[] = $as->expr;
			}
			$snippet->expr = "$name(".implode(", ", $args).")";
			$snippet->exprRequired = true;
		}
		else if ($expr instanceof Entity\Expr\ElementAccess) {
			$es = $this->generateExprCode($expr->getExpr());
			$is = $this->generateExprCode($expr->getIndex());
			$snippet->stmts .= $es->stmts;
			$snippet->stmts .= $is->stmts;
			$snippet->expr = "{$es->expr}[{$is->expr}]";
		}
		else if ($expr instanceof Entity\Expr\Cast) {
			$es = $this->generateExprCode($expr->getExpr());
			$snippet->stmts .= $es->stmts;
			$snippet->expr = "({$expr->compiler->type->getCType()})({$es->expr})";
		}
		else {
			throw new \exception("Unable to generate expression code for ".vartype($expr));
		}
		return $snippet;
	}

	/**
	 * Recursively checks the given entity for any generic types, returning
	 * true if one is found, indicating that the entity cannot be compiled to
	 * C code as is.
	 */
	public function isEntityGeneric(Entity\Entity $entity)
	{
		foreach ($entity->getChildEntities() as $e) {
			if ($this->isEntityGeneric($e)) {
				return true;
			}
		}

		if ($entity instanceof Entity\Type\Member) {
			if ($entity->getType() instanceof \Type\Generic)
				return true;
		}
		if ($entity instanceof Entity\Type\TypeVar) {
			if ($entity->getType() instanceof \Type\Generic)
				return true;
		}

		return false;
	}
}